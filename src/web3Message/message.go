// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package message

import "fmt"
import "reflect"
import "encoding/json"

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitPlaceableLands) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitPlaceableLands {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitPlaceableLands, v)
	}
	*j = NFTTraitPlaceableLands(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Web3ServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Web3ServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Web3ServiceAction, v)
	}
	*j = Web3ServiceAction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppId) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppId {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppId, v)
	}
	*j = AppId(v)
	return nil
}

const AppIdGameServiceMain AppId = "game-service-main"
const AppIdMelandService AppId = "meland-service"
const AppIdPvpService AppId = "pvp-service"
const AppIdSceneDynamicService AppId = "scene-dynamic-service"
const AppIdWeb3Service AppId = "web3-service"

type AuthUserType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType_1, v)
	}
	*j = UserType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthUserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthUserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthUserType, v)
	}
	*j = AuthUserType(v)
	return nil
}

const AuthUserTypeMANAGER AuthUserType = "MANAGER"
const AuthUserTypeSTUDENT AuthUserType = "STUDENT"
const AuthUserTypeTEACHER AuthUserType = "TEACHER"

type Auth struct {
	// AccessToken corresponds to the JSON schema field "accessToken".
	AccessToken string `json:"accessToken"`

	// UserType corresponds to the JSON schema field "userType".
	UserType *AuthUserType `json:"userType,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Auth) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["accessToken"]; !ok || v == nil {
		return fmt.Errorf("field accessToken: required")
	}
	type Plain Auth
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Auth(plain)
	return nil
}

type BatchMintNFTWithItemIdInputQualitysElem string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserStakeHarvest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["harvestAmountOfMELD"]; !ok || v == nil {
		return fmt.Errorf("field harvestAmountOfMELD: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain UserStakeHarvest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserStakeHarvest(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFTWithItemIdInputQualitysElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BatchMintNFTWithItemIdInputQualitysElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BatchMintNFTWithItemIdInputQualitysElem, v)
	}
	*j = BatchMintNFTWithItemIdInputQualitysElem(v)
	return nil
}

const BatchMintNFTWithItemIdInputQualitysElemAdvanced BatchMintNFTWithItemIdInputQualitysElem = "Advanced"
const BatchMintNFTWithItemIdInputQualitysElemBasic BatchMintNFTWithItemIdInputQualitysElem = "Basic"
const BatchMintNFTWithItemIdInputQualitysElemEnhanced BatchMintNFTWithItemIdInputQualitysElem = "Enhanced"
const BatchMintNFTWithItemIdInputQualitysElemSuper BatchMintNFTWithItemIdInputQualitysElem = "Super"
const BatchMintNFTWithItemIdInputQualitysElemUltimate BatchMintNFTWithItemIdInputQualitysElem = "Ultimate"

type BatchMintNFTWithItemIdInput struct {
	// index和itemIds一一对应
	// 所有数量
	Amounts []int `json:"amounts"`

	// Async corresponds to the JSON schema field "async".
	Async bool `json:"async"`

	// 需要mint的所有的itemId
	ItemIds []string `json:"itemIds"`

	// 玩家所在的坐标landId,
	// 当mint场景是捡取掉落物时携带
	LandId int `json:"landId"`

	// 所有的品质
	// index和itemIds一一对应
	QualityVals []string `json:"qualityVals,omitempty"`

	// 所有的品质
	// index和itemIds一一对应
	Qualitys []BatchMintNFTWithItemIdInputQualitysElem `json:"qualitys,omitempty"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFTWithItemIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amounts"]; !ok || v == nil {
		return fmt.Errorf("field amounts: required")
	}
	if v, ok := raw["async"]; !ok || v == nil {
		return fmt.Errorf("field async: required")
	}
	if v, ok := raw["itemIds"]; !ok || v == nil {
		return fmt.Errorf("field itemIds: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain BatchMintNFTWithItemIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchMintNFTWithItemIdInput(plain)
	return nil
}

type BatchMintNFTWithItemIdOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFTWithItemIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain BatchMintNFTWithItemIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchMintNFTWithItemIdOutput(plain)
	return nil
}

type BuildData struct {
	// 建造id
	BuildId int `json:"buildId"`

	// 下次可采集(偷取)的时间戳 单位秒
	CollectionAt int `json:"collectionAt"`

	// 可采集(偷取)物品数量统计
	CollectionItemCount int `json:"collectionItemCount"`

	// 采集开始时间点
	CollectionStartAt int `json:"collectionStartAt"`

	// 电量过期时间 单位秒
	ElectricEnd int `json:"electricEnd"`

	// 可以收集的时间
	HarvestAt int `json:"harvestAt"`

	// 可收获的物品数量统计(没电时转移到采集) 单位秒
	HarvestItemCount int `json:"harvestItemCount"`

	// 产出开始时间点.
	HarvestStartAt int `json:"harvestStartAt"`

	// LandIds corresponds to the JSON schema field "landIds".
	LandIds []int `json:"landIds"`

	// LandPlacementPowerZeroCooldownAt corresponds to the JSON schema field
	// "landPlacementPowerZeroCooldownAt".
	LandPlacementPowerZeroCooldownAt int `json:"landPlacementPowerZeroCooldownAt"`

	// LandPlacementPowerZeroCooldownStartAt corresponds to the JSON schema field
	// "landPlacementPowerZeroCooldownStartAt".
	LandPlacementPowerZeroCooldownStartAt int `json:"landPlacementPowerZeroCooldownStartAt"`

	// 地图id 为多地图准备
	MapId int `json:"mapId"`

	// nftId
	NftId string `json:"nftId"`

	// 玩家id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildId"]; !ok || v == nil {
		return fmt.Errorf("field buildId: required")
	}
	if v, ok := raw["collectionAt"]; !ok || v == nil {
		return fmt.Errorf("field collectionAt: required")
	}
	if v, ok := raw["collectionItemCount"]; !ok || v == nil {
		return fmt.Errorf("field collectionItemCount: required")
	}
	if v, ok := raw["collectionStartAt"]; !ok || v == nil {
		return fmt.Errorf("field collectionStartAt: required")
	}
	if v, ok := raw["electricEnd"]; !ok || v == nil {
		return fmt.Errorf("field electricEnd: required")
	}
	if v, ok := raw["harvestAt"]; !ok || v == nil {
		return fmt.Errorf("field harvestAt: required")
	}
	if v, ok := raw["harvestItemCount"]; !ok || v == nil {
		return fmt.Errorf("field harvestItemCount: required")
	}
	if v, ok := raw["harvestStartAt"]; !ok || v == nil {
		return fmt.Errorf("field harvestStartAt: required")
	}
	if v, ok := raw["landIds"]; !ok || v == nil {
		return fmt.Errorf("field landIds: required")
	}
	if v, ok := raw["landPlacementPowerZeroCooldownAt"]; !ok || v == nil {
		return fmt.Errorf("field landPlacementPowerZeroCooldownAt: required")
	}
	if v, ok := raw["landPlacementPowerZeroCooldownStartAt"]; !ok || v == nil {
		return fmt.Errorf("field landPlacementPowerZeroCooldownStartAt: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain BuildData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuildData(plain)
	return nil
}

type BuildInput struct {
	// LandIds corresponds to the JSON schema field "landIds".
	LandIds []int `json:"landIds"`

	// 地图id 为多地图准备
	MapId int `json:"mapId"`

	// nftId
	NftId string `json:"nftId"`

	// 玩家id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["landIds"]; !ok || v == nil {
		return fmt.Errorf("field landIds: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain BuildInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuildInput(plain)
	return nil
}

type BuildOutput struct {
	// 建造物信息
	BuildData *BuildData `json:"buildData,omitempty"`

	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason"`

	// 是否成功
	Success bool `json:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	type Plain BuildOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuildOutput(plain)
	return nil
}

type DitaminBurnSource string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserStakeExpire) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amountOfMELD"]; !ok || v == nil {
		return fmt.Errorf("field amountOfMELD: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["stakeLevel"]; !ok || v == nil {
		return fmt.Errorf("field stakeLevel: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain UserStakeExpire
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserStakeExpire(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminBurnSource) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DitaminBurnSource {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DitaminBurnSource, v)
	}
	*j = DitaminBurnSource(v)
	return nil
}

const DitaminBurnSourceBuild3DrNFT DitaminBurnSource = "build3drNFT"
const DitaminBurnSourceBuildNFT DitaminBurnSource = "buildNFT"
const DitaminBurnSourceBuyEnergy DitaminBurnSource = "buyEnergy"
const DitaminBurnSourceCraft DitaminBurnSource = "craft"
const DitaminBurnSourceExchange DitaminBurnSource = "exchange"

type BurnDitaminInput struct {
	// 需要燃烧的ditamin数量
	Amount string `json:"amount"`

	// 燃烧的原因
	Source DitaminBurnSource `json:"source"`

	// 燃烧的hash id
	// 用来防止重复燃烧, 每次燃烧调用方需要生成一个txHash.
	// 如果txHash重复, 则不会重复燃烧
	TxHash string `json:"txHash"`

	// 需要燃烧的用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BurnDitaminInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source: required")
	}
	if v, ok := raw["txHash"]; !ok || v == nil {
		return fmt.Errorf("field txHash: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain BurnDitaminInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BurnDitaminInput(plain)
	return nil
}

type BurnDitaminOutput struct {
	// 是否燃烧成功
	BurnSuccess bool `json:"burnSuccess"`

	// 如果燃烧失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BurnDitaminOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["burnSuccess"]; !ok || v == nil {
		return fmt.Errorf("field burnSuccess: required")
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason: required")
	}
	type Plain BurnDitaminOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BurnDitaminOutput(plain)
	return nil
}

type BurnNFTInput struct {
	// 丢弃的数量
	Amount int `json:"amount"`

	// 丢弃的NFTId
	NftId string `json:"nftId"`

	// 用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BurnNFTInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain BurnNFTInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BurnNFTInput(plain)
	return nil
}

type BurnNFTOutput struct {
	// 是否丢弃成功
	Success bool `json:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BurnNFTOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	type Plain BurnNFTOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BurnNFTOutput(plain)
	return nil
}

type CanBuildNFTInput struct {
	// 实体存活时间，对第三方NFT有效, 单位(秒)
	AliveTimeSec int `json:"aliveTimeSec"`

	// NFT Id
	NftId string `json:"nftId"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CanBuildNFTInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["aliveTimeSec"]; !ok || v == nil {
		return fmt.Errorf("field aliveTimeSec: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain CanBuildNFTInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CanBuildNFTInput(plain)
	return nil
}

type CanBuildNFTOutput struct {
	// CanBuild corresponds to the JSON schema field "canBuild".
	CanBuild bool `json:"canBuild"`

	// NFT id
	NftId string `json:"nftId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CanBuildNFTOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["canBuild"]; !ok || v == nil {
		return fmt.Errorf("field canBuild: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	type Plain CanBuildNFTOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CanBuildNFTOutput(plain)
	return nil
}

type ChargedInput struct {
	// 建造id
	BuildId int `json:"buildId"`

	// 地图id 为多地图准备
	MapId int `json:"mapId"`

	// 电池数量
	Num int `json:"num"`

	// 玩家id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChargedInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildId"]; !ok || v == nil {
		return fmt.Errorf("field buildId: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId: required")
	}
	if v, ok := raw["num"]; !ok || v == nil {
		return fmt.Errorf("field num: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain ChargedInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ChargedInput(plain)
	return nil
}

type ChargedOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason"`

	// 是否成功
	Success bool `json:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChargedOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	type Plain ChargedOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ChargedOutput(plain)
	return nil
}

type CheckQuestionAnswerInput struct {
	// AnswerJSON corresponds to the JSON schema field "answerJSON".
	AnswerJSON string `json:"answerJSON"`

	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckQuestionAnswerInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["answerJSON"]; !ok || v == nil {
		return fmt.Errorf("field answerJSON: required")
	}
	if v, ok := raw["questionId"]; !ok || v == nil {
		return fmt.Errorf("field questionId: required")
	}
	type Plain CheckQuestionAnswerInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckQuestionAnswerInput(plain)
	return nil
}

type CheckQuestionAnswerOutput struct {
	// IsCorrect corresponds to the JSON schema field "isCorrect".
	IsCorrect bool `json:"isCorrect"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckQuestionAnswerOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["isCorrect"]; !ok || v == nil {
		return fmt.Errorf("field isCorrect: required")
	}
	type Plain CheckQuestionAnswerOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckQuestionAnswerOutput(plain)
	return nil
}

type CloseServer struct {
	// ServerAppId corresponds to the JSON schema field "serverAppId".
	ServerAppId string `json:"serverAppId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CloseServer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["serverAppId"]; !ok || v == nil {
		return fmt.Errorf("field serverAppId: required")
	}
	type Plain CloseServer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CloseServer(plain)
	return nil
}

type CollectionInput struct {
	// 建造Id
	BuildId int `json:"buildId"`

	// 地图id 为多地图准备
	MapId int `json:"mapId"`

	// 玩家id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CollectionInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildId"]; !ok || v == nil {
		return fmt.Errorf("field buildId: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain CollectionInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CollectionInput(plain)
	return nil
}

type CollectionOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason"`

	// 是否成功
	Success bool `json:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CollectionOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	type Plain CollectionOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CollectionOutput(plain)
	return nil
}

type CreatePVPRoomInput map[string]interface{}

type CreatePVPRoomOutput struct {
	// RoomId corresponds to the JSON schema field "roomId".
	RoomId string `json:"roomId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CreatePVPRoomOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["roomId"]; !ok || v == nil {
		return fmt.Errorf("field roomId: required")
	}
	type Plain CreatePVPRoomOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CreatePVPRoomOutput(plain)
	return nil
}

type DeductUserExpInput struct {
	// DeductExp corresponds to the JSON schema field "deductExp".
	DeductExp int `json:"deductExp"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeductUserExpInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["deductExp"]; !ok || v == nil {
		return fmt.Errorf("field deductExp: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain DeductUserExpInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DeductUserExpInput(plain)
	return nil
}

type DeductUserExpOutput struct {
	// 是否扣除成功
	DeductSuccess bool `json:"deductSuccess"`

	// 如果扣除失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeductUserExpOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["deductSuccess"]; !ok || v == nil {
		return fmt.Errorf("field deductSuccess: required")
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason: required")
	}
	type Plain DeductUserExpOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DeductUserExpOutput(plain)
	return nil
}

type DitaminBurnSource_2 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserStakeClaim) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amountOfMELD"]; !ok || v == nil {
		return fmt.Errorf("field amountOfMELD: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["stakeLevel"]; !ok || v == nil {
		return fmt.Errorf("field stakeLevel: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain UserStakeClaim
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserStakeClaim(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminBurnSource_2) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DitaminBurnSource_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DitaminBurnSource_2, v)
	}
	*j = DitaminBurnSource_2(v)
	return nil
}

const DitaminBurnSource_2_Build3DrNFT DitaminBurnSource_2 = "build3drNFT"
const DitaminBurnSource_2_BuildNFT DitaminBurnSource_2 = "buildNFT"
const DitaminBurnSource_2_BuyEnergy DitaminBurnSource_2 = "buyEnergy"
const DitaminBurnSource_2_Craft DitaminBurnSource_2 = "craft"

type AppId string

type DitaminBurn struct {
	// ditamin数量
	DitaminAmount string `json:"ditaminAmount"`

	// 消息版本号
	Etag int `json:"etag"`

	// 生产源
	Source DitaminBurnSource_2 `json:"source"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminBurn) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ditaminAmount"]; !ok || v == nil {
		return fmt.Errorf("field ditaminAmount: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain DitaminBurn
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DitaminBurn(plain)
	return nil
}

type DitaminBurnSource_1 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserStakeAdd) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amountOfMELD"]; !ok || v == nil {
		return fmt.Errorf("field amountOfMELD: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["stakeLevel"]; !ok || v == nil {
		return fmt.Errorf("field stakeLevel: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain UserStakeAdd
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserStakeAdd(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminBurnSource_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DitaminBurnSource_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DitaminBurnSource_1, v)
	}
	*j = DitaminBurnSource_1(v)
	return nil
}

const DitaminBurnSource_1_Build3DrNFT DitaminBurnSource_1 = "build3drNFT"
const DitaminBurnSource_1_BuildNFT DitaminBurnSource_1 = "buildNFT"
const DitaminBurnSource_1_BuyEnergy DitaminBurnSource_1 = "buyEnergy"
const DitaminBurnSource_1_Craft DitaminBurnSource_1 = "craft"
const DitaminBurnSource_1_Exchange DitaminBurnSource_1 = "exchange"

type DitaminProduceSource_1 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *User) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatar"]; !ok || v == nil {
		return fmt.Errorf("field avatar: required")
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["mobile"]; !ok || v == nil {
		return fmt.Errorf("field mobile: required")
	}
	if v, ok := raw["nickname"]; !ok || v == nil {
		return fmt.Errorf("field nickname: required")
	}
	if v, ok := raw["realname"]; !ok || v == nil {
		return fmt.Errorf("field realname: required")
	}
	if v, ok := raw["schoolId"]; !ok || v == nil {
		return fmt.Errorf("field schoolId: required")
	}
	if v, ok := raw["sex"]; !ok || v == nil {
		return fmt.Errorf("field sex: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username: required")
	}
	if v, ok := raw["usertype"]; !ok || v == nil {
		return fmt.Errorf("field usertype: required")
	}
	type Plain User
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = User(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminProduceSource_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DitaminProduceSource_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DitaminProduceSource_1, v)
	}
	*j = DitaminProduceSource_1(v)
	return nil
}

const DitaminProduceSource_1_AttackFinlish DitaminProduceSource_1 = "attackFinlish"
const DitaminProduceSource_1_Deposit DitaminProduceSource_1 = "deposit"
const DitaminProduceSource_1_Harvest DitaminProduceSource_1 = "harvest"

type DitaminProduce struct {
	// ditamin数量
	DitaminAmount string `json:"ditaminAmount"`

	// 消息版本号
	Etag int `json:"etag"`

	// 生产源
	Source DitaminProduceSource_1 `json:"source"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminProduce) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ditaminAmount"]; !ok || v == nil {
		return fmt.Errorf("field ditaminAmount: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain DitaminProduce
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DitaminProduce(plain)
	return nil
}

type DitaminProduceSource string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType, v)
	}
	*j = UserType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminProduceSource) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DitaminProduceSource {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DitaminProduceSource, v)
	}
	*j = DitaminProduceSource(v)
	return nil
}

const DitaminProduceSourceAttackFinlish DitaminProduceSource = "attackFinlish"
const DitaminProduceSourceDeposit DitaminProduceSource = "deposit"
const DitaminProduceSourceHarvest DitaminProduceSource = "harvest"

type FinishQuestion struct {
	// DiffcultyChange corresponds to the JSON schema field "diffcultyChange".
	DiffcultyChange float64 `json:"diffcultyChange"`

	// 消息版本号
	Etag int `json:"etag"`

	// Level corresponds to the JSON schema field "level".
	Level string `json:"level"`

	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId"`

	// Result corresponds to the JSON schema field "result".
	Result string `json:"result"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FinishQuestion) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["diffcultyChange"]; !ok || v == nil {
		return fmt.Errorf("field diffcultyChange: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level: required")
	}
	if v, ok := raw["questionId"]; !ok || v == nil {
		return fmt.Errorf("field questionId: required")
	}
	if v, ok := raw["result"]; !ok || v == nil {
		return fmt.Errorf("field result: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain FinishQuestion
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FinishQuestion(plain)
	return nil
}

type ForgetUserRecipesInput struct {
	// RecipeIds corresponds to the JSON schema field "recipeIds".
	RecipeIds []string `json:"recipeIds"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ForgetUserRecipesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["recipeIds"]; !ok || v == nil {
		return fmt.Errorf("field recipeIds: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain ForgetUserRecipesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ForgetUserRecipesInput(plain)
	return nil
}

type ForgetUserRecipesOutput map[string]interface{}

type GameDataServiceAction string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex_1, v)
	}
	*j = Sex_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GameDataServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GameDataServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GameDataServiceAction, v)
	}
	*j = GameDataServiceAction(v)
	return nil
}

const GameDataServiceActionDeductUserExp GameDataServiceAction = "DeductUserExp"
const GameDataServiceActionGetPlayerInfoByUserId GameDataServiceAction = "GetPlayerInfoByUserId"
const GameDataServiceActionGetPlayerItemSlots GameDataServiceAction = "GetPlayerItemSlots"
const GameDataServiceActionGetPlayerUsingNftsByUserId GameDataServiceAction = "GetPlayerUsingNftsByUserId"
const GameDataServiceActionLandUsingSkill GameDataServiceAction = "LandUsingSkill"
const GameDataServiceActionMultiGetPlayerInfoByUserId GameDataServiceAction = "MultiGetPlayerInfoByUserId"
const GameDataServiceActionMultiGetPlayerUsingNftsByUserId GameDataServiceAction = "MultiGetPlayerUsingNftsByUserId"
const GameDataServiceActionUpgradePlayerItemSlots GameDataServiceAction = "UpgradePlayerItemSlots"

type GetAllBuildDataInput struct {
	// 地图id 为多地图准备
	MapId int `json:"mapId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAllBuildDataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId: required")
	}
	type Plain GetAllBuildDataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAllBuildDataInput(plain)
	return nil
}

type GetAllBuildDataOutput struct {
	// 全量建造物数据
	AllBuild []BuildData `json:"allBuild,omitempty"`

	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason"`

	// 是否成功
	Success bool `json:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAllBuildDataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	type Plain GetAllBuildDataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAllBuildDataOutput(plain)
	return nil
}

type GetAllLandDataInput struct {
	// 地图id 为多地图准备
	MapId int `json:"mapId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAllLandDataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId: required")
	}
	type Plain GetAllLandDataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAllLandDataInput(plain)
	return nil
}

// 地格数据结构
type LandData struct {
	// 地格id地图唯一
	Id int `json:"id"`

	// 地图id 为多地图准备
	MapId int `json:"mapId"`

	// 占领时间 单位秒
	OccupyAt int `json:"occupyAt"`

	// owner userId
	OwnerId string `json:"ownerId"`

	// 占领过期时间 单位秒
	// 当地块上存在有电量建筑物时，
	// 该时间戳无效 || 在充电时更新该时间戳
	TimeoutAt int `json:"timeoutAt"`

	// 地格坐标
	X float64 `json:"x"`

	// Y corresponds to the JSON schema field "y".
	Y float64 `json:"y"`

	// Z corresponds to the JSON schema field "z".
	Z float64 `json:"z"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId: required")
	}
	if v, ok := raw["occupyAt"]; !ok || v == nil {
		return fmt.Errorf("field occupyAt: required")
	}
	if v, ok := raw["ownerId"]; !ok || v == nil {
		return fmt.Errorf("field ownerId: required")
	}
	if v, ok := raw["timeoutAt"]; !ok || v == nil {
		return fmt.Errorf("field timeoutAt: required")
	}
	if v, ok := raw["x"]; !ok || v == nil {
		return fmt.Errorf("field x: required")
	}
	if v, ok := raw["y"]; !ok || v == nil {
		return fmt.Errorf("field y: required")
	}
	if v, ok := raw["z"]; !ok || v == nil {
		return fmt.Errorf("field z: required")
	}
	type Plain LandData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandData(plain)
	return nil
}

type GetAllLandDataOutput struct {
	// 全量地格数据
	AllLandData []LandData `json:"allLandData,omitempty"`

	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason"`

	// 是否成功
	Success bool `json:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAllLandDataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	type Plain GetAllLandDataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAllLandDataOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseMELDOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	type Plain UseMELDOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseMELDOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseMELDInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UseMELDInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseMELDInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPUserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPUserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPUserType, v)
	}
	*j = PVPUserType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseEquipment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatarPos"]; !ok || v == nil {
		return fmt.Errorf("field avatarPos: required")
	}
	if v, ok := raw["cid"]; !ok || v == nil {
		return fmt.Errorf("field cid: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UseEquipment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseEquipment(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseConsumabled) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["nft"]; !ok || v == nil {
		return fmt.Errorf("field nft: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UseConsumabled
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseConsumabled(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseConsumableOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UseConsumableOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseConsumableOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPPlayer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain PVPPlayer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPPlayer(plain)
	return nil
}

type GetCurrentPkSessionIdInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetCurrentPkSessionIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	type Plain GetCurrentPkSessionIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetCurrentPkSessionIdInput(plain)
	return nil
}

type GetCurrentPkSessionIdOutput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetCurrentPkSessionIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId: required")
	}
	type Plain GetCurrentPkSessionIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetCurrentPkSessionIdOutput(plain)
	return nil
}

type GetPlayerInfoByUserIdInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerInfoByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetPlayerInfoByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerInfoByUserIdInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseConsumableInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UseConsumableInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseConsumableInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["curExp"]; !ok || v == nil {
		return fmt.Errorf("field curExp: required")
	}
	if v, ok := raw["curHp"]; !ok || v == nil {
		return fmt.Errorf("field curHp: required")
	}
	if v, ok := raw["feature"]; !ok || v == nil {
		return fmt.Errorf("field feature: required")
	}
	if v, ok := raw["icon"]; !ok || v == nil {
		return fmt.Errorf("field icon: required")
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level: required")
	}
	if v, ok := raw["playerName"]; !ok || v == nil {
		return fmt.Errorf("field playerName: required")
	}
	if v, ok := raw["roleCId"]; !ok || v == nil {
		return fmt.Errorf("field roleCId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain PlayerInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerInfo(plain)
	return nil
}

type GetPlayerInfoByUserIdOutput struct {
	// PlayerData corresponds to the JSON schema field "playerData".
	PlayerData PlayerInfo `json:"playerData"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerInfoByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerData"]; !ok || v == nil {
		return fmt.Errorf("field playerData: required")
	}
	type Plain GetPlayerInfoByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerInfoByUserIdOutput(plain)
	return nil
}

type GetPlayerItemSlotsInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerItemSlotsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetPlayerItemSlotsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerItemSlotsInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpgradePlayerItemSlotsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UpgradePlayerItemSlotsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpgradePlayerItemSlotsOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerItemSlot) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position: required")
	}
	type Plain PlayerItemSlot
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerItemSlot(plain)
	return nil
}

type GetPlayerItemSlotsOutput struct {
	// ItemSlots corresponds to the JSON schema field "itemSlots".
	ItemSlots []PlayerItemSlot `json:"itemSlots"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerItemSlotsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["itemSlots"]; !ok || v == nil {
		return fmt.Errorf("field itemSlots: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetPlayerItemSlotsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerItemSlotsOutput(plain)
	return nil
}

type GetPlayerPvpProfileInput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpProfileInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	type Plain GetPlayerPvpProfileInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpProfileInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpgradePlayerItemSlotsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["itemSlots"]; !ok || v == nil {
		return fmt.Errorf("field itemSlots: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UpgradePlayerItemSlotsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpgradePlayerItemSlotsInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerAvatar) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["cid"]; !ok || v == nil {
		return fmt.Errorf("field cid: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["nftJson"]; !ok || v == nil {
		return fmt.Errorf("field nftJson: required")
	}
	if v, ok := raw["pos"]; !ok || v == nil {
		return fmt.Errorf("field pos: required")
	}
	type Plain PlayerAvatar
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerAvatar(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpdateUserNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["fromLandId"]; !ok || v == nil {
		return fmt.Errorf("field fromLandId: required")
	}
	if v, ok := raw["nft"]; !ok || v == nil {
		return fmt.Errorf("field nft: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UpdateUserNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpdateUserNFT(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpPlayerProfile) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatars"]; !ok || v == nil {
		return fmt.Errorf("field avatars: required")
	}
	if v, ok := raw["baseInfo"]; !ok || v == nil {
		return fmt.Errorf("field baseInfo: required")
	}
	if v, ok := raw["itemSlots"]; !ok || v == nil {
		return fmt.Errorf("field itemSlots: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["score"]; !ok || v == nil {
		return fmt.Errorf("field score: required")
	}
	type Plain PvpPlayerProfile
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpPlayerProfile(plain)
	return nil
}

type GetPlayerPvpProfileOutput struct {
	// Profile corresponds to the JSON schema field "profile".
	Profile PvpPlayerProfile `json:"profile"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpProfileOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["profile"]; !ok || v == nil {
		return fmt.Errorf("field profile: required")
	}
	type Plain GetPlayerPvpProfileOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpProfileOutput(plain)
	return nil
}

type GetPlayerPvpRankInput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpRankInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	type Plain GetPlayerPvpRankInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpRankInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpdateUpcomingUses) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["number"]; !ok || v == nil {
		return fmt.Errorf("field number: required")
	}
	type Plain UpdateUpcomingUses
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpdateUpcomingUses(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpPlayerRank) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatars"]; !ok || v == nil {
		return fmt.Errorf("field avatars: required")
	}
	if v, ok := raw["baseInfo"]; !ok || v == nil {
		return fmt.Errorf("field baseInfo: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["rank"]; !ok || v == nil {
		return fmt.Errorf("field rank: required")
	}
	if v, ok := raw["score"]; !ok || v == nil {
		return fmt.Errorf("field score: required")
	}
	type Plain PvpPlayerRank
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpPlayerRank(plain)
	return nil
}

type GetPlayerPvpRankOutput struct {
	// RankList corresponds to the JSON schema field "rankList".
	RankList []PvpPlayerRank `json:"rankList"`

	// SelfRank corresponds to the JSON schema field "selfRank".
	SelfRank PvpPlayerRank `json:"selfRank"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpRankOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["rankList"]; !ok || v == nil {
		return fmt.Errorf("field rankList: required")
	}
	if v, ok := raw["selfRank"]; !ok || v == nil {
		return fmt.Errorf("field selfRank: required")
	}
	type Plain GetPlayerPvpRankOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpRankOutput(plain)
	return nil
}

type GetPlayerUsingNftsByUserIdInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerUsingNftsByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetPlayerUsingNftsByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerUsingNftsByUserIdInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnloadEquipment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UnloadEquipment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UnloadEquipment(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UsingNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatarPos"]; !ok || v == nil {
		return fmt.Errorf("field avatarPos: required")
	}
	if v, ok := raw["cid"]; !ok || v == nil {
		return fmt.Errorf("field cid: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UsingNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UsingNFT(plain)
	return nil
}

type GetPlayerUsingNftsByUserIdOutput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`

	// UsingNfts corresponds to the JSON schema field "usingNfts".
	UsingNfts []UsingNFT `json:"usingNfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerUsingNftsByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	if v, ok := raw["usingNfts"]; !ok || v == nil {
		return fmt.Errorf("field usingNfts: required")
	}
	type Plain GetPlayerUsingNftsByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerUsingNftsByUserIdOutput(plain)
	return nil
}

type GetPvpHistoryInput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPvpHistoryInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	type Plain GetPvpHistoryInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPvpHistoryInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["createdAt"]; !ok || v == nil {
		return fmt.Errorf("field createdAt: required")
	}
	if v, ok := raw["expiredAt"]; !ok || v == nil {
		return fmt.Errorf("field expiredAt: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["token"]; !ok || v == nil {
		return fmt.Errorf("field token: required")
	}
	if v, ok := raw["updatedAt"]; !ok || v == nil {
		return fmt.Errorf("field updatedAt: required")
	}
	type Plain TemporaryToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryToken(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpHistory) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["endType"]; !ok || v == nil {
		return fmt.Errorf("field endType: required")
	}
	if v, ok := raw["loser"]; !ok || v == nil {
		return fmt.Errorf("field loser: required")
	}
	if v, ok := raw["loserName"]; !ok || v == nil {
		return fmt.Errorf("field loserName: required")
	}
	if v, ok := raw["loserScore"]; !ok || v == nil {
		return fmt.Errorf("field loserScore: required")
	}
	if v, ok := raw["pvpType"]; !ok || v == nil {
		return fmt.Errorf("field pvpType: required")
	}
	if v, ok := raw["scoreOffset"]; !ok || v == nil {
		return fmt.Errorf("field scoreOffset: required")
	}
	if v, ok := raw["timeSec"]; !ok || v == nil {
		return fmt.Errorf("field timeSec: required")
	}
	if v, ok := raw["winner"]; !ok || v == nil {
		return fmt.Errorf("field winner: required")
	}
	if v, ok := raw["winnerName"]; !ok || v == nil {
		return fmt.Errorf("field winnerName: required")
	}
	if v, ok := raw["winnerScore"]; !ok || v == nil {
		return fmt.Errorf("field winnerScore: required")
	}
	type Plain PvpHistory
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpHistory(plain)
	return nil
}

type GetPvpHistoryOutput struct {
	// HistoryList corresponds to the JSON schema field "historyList".
	HistoryList []PvpHistory `json:"historyList"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPvpHistoryOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["historyList"]; !ok || v == nil {
		return fmt.Errorf("field historyList: required")
	}
	type Plain GetPvpHistoryOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPvpHistoryOutput(plain)
	return nil
}

type GetQuestionResourcesByTypesInput struct {
	// Types corresponds to the JSON schema field "types".
	Types []string `json:"types"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionResourcesByTypesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["types"]; !ok || v == nil {
		return fmt.Errorf("field types: required")
	}
	type Plain GetQuestionResourcesByTypesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionResourcesByTypesInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryTokenExtraInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain TemporaryTokenExtraInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryTokenExtraInfo(plain)
	return nil
}

type Integer float64

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuestionType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuestionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuestionType, v)
	}
	*j = QuestionType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionEvent) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SubscriptionEvent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SubscriptionEvent, v)
	}
	*j = SubscriptionEvent(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StartServerOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["serverAppId"]; !ok || v == nil {
		return fmt.Errorf("field serverAppId: required")
	}
	type Plain StartServerOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StartServerOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StartServerInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["args"]; !ok || v == nil {
		return fmt.Errorf("field args: required")
	}
	if v, ok := raw["envs"]; !ok || v == nil {
		return fmt.Errorf("field envs: required")
	}
	type Plain StartServerInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StartServerInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SmapleNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata: required")
	}
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId: required")
	}
	type Plain SmapleNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SmapleNFT(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex, v)
	}
	*j = Sex(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendTxOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain SendTxOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SendTxOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendTxInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data: required")
	}
	if v, ok := raw["gas"]; !ok || v == nil {
		return fmt.Errorf("field gas: required")
	}
	if v, ok := raw["to"]; !ok || v == nil {
		return fmt.Errorf("field to: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain SendTxInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SendTxInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendMetaTxOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain SendMetaTxOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SendMetaTxOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendMetaTxInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data: required")
	}
	if v, ok := raw["from"]; !ok || v == nil {
		return fmt.Errorf("field from: required")
	}
	if v, ok := raw["gas"]; !ok || v == nil {
		return fmt.Errorf("field gas: required")
	}
	if v, ok := raw["nonce"]; !ok || v == nil {
		return fmt.Errorf("field nonce: required")
	}
	if v, ok := raw["signature"]; !ok || v == nil {
		return fmt.Errorf("field signature: required")
	}
	if v, ok := raw["to"]; !ok || v == nil {
		return fmt.Errorf("field to: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain SendMetaTxInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SendMetaTxInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SceneDynamicServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SceneDynamicServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SceneDynamicServiceAction, v)
	}
	*j = SceneDynamicServiceAction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecyclingOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	type Plain RecyclingOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecyclingOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecyclingInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildId"]; !ok || v == nil {
		return fmt.Errorf("field buildId: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain RecyclingInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecyclingInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuestionType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuestionType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuestionType_1, v)
	}
	*j = QuestionType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Prefetch) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["questionId"]; !ok || v == nil {
		return fmt.Errorf("field questionId: required")
	}
	if v, ok := raw["questionType"]; !ok || v == nil {
		return fmt.Errorf("field questionType: required")
	}
	if v, ok := raw["resources"]; !ok || v == nil {
		return fmt.Errorf("field resources: required")
	}
	type Plain Prefetch
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Prefetch(plain)
	return nil
}

type GetQuestionResourcesByTypesOutput struct {
	// Prefetchs corresponds to the JSON schema field "prefetchs".
	Prefetchs []Prefetch `json:"prefetchs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionResourcesByTypesOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["prefetchs"]; !ok || v == nil {
		return fmt.Errorf("field prefetchs: required")
	}
	type Plain GetQuestionResourcesByTypesOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionResourcesByTypesOutput(plain)
	return nil
}

type GetQuestionsByTypesRandomInput struct {
	// Limit corresponds to the JSON schema field "limit".
	Limit int `json:"limit"`

	// Types corresponds to the JSON schema field "types".
	Types []string `json:"types"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionsByTypesRandomInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["limit"]; !ok || v == nil {
		return fmt.Errorf("field limit: required")
	}
	if v, ok := raw["types"]; !ok || v == nil {
		return fmt.Errorf("field types: required")
	}
	type Plain GetQuestionsByTypesRandomInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionsByTypesRandomInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpSurrenderOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	type Plain PvpSurrenderOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpSurrenderOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Question) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["structJSON"]; !ok || v == nil {
		return fmt.Errorf("field structJSON: required")
	}
	type Plain Question
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Question(plain)
	return nil
}

type GetQuestionsByTypesRandomOutput struct {
	// Questions corresponds to the JSON schema field "questions".
	Questions []Question `json:"questions"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionsByTypesRandomOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["questions"]; !ok || v == nil {
		return fmt.Errorf("field questions: required")
	}
	type Plain GetQuestionsByTypesRandomOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionsByTypesRandomOutput(plain)
	return nil
}

type GetUserIdByAddressInput struct {
	// BlockchainAddress corresponds to the JSON schema field "blockchainAddress".
	BlockchainAddress string `json:"blockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserIdByAddressInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field blockchainAddress: required")
	}
	type Plain GetUserIdByAddressInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserIdByAddressInput(plain)
	return nil
}

type GetUserIdByAddressOutput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserIdByAddressOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserIdByAddressOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserIdByAddressOutput(plain)
	return nil
}

type GetUserNFTsByUserIdAndAddressInput struct {
	// 用户钱包地址
	BlockchainAddress string `json:"blockchainAddress"`

	// 用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsByUserIdAndAddressInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field blockchainAddress: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserNFTsByUserIdAndAddressInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsByUserIdAndAddressInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpSurrenderInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	type Plain PvpSurrenderInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpSurrenderInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTAttribute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["trait_type"]; !ok || v == nil {
		return fmt.Errorf("field trait_type: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain NFTAttribute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTAttribute(plain)
	return nil
}

// 有一些配置表格的数据不希望显示在opensea中,
// 但是为了方便统一解析。
// 生成到这个表格中.
type MelandAttribute struct {
	// TraitType corresponds to the JSON schema field "trait_type".
	TraitType string `json:"trait_type"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MelandAttribute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["trait_type"]; !ok || v == nil {
		return fmt.Errorf("field trait_type: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain MelandAttribute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MelandAttribute(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerRebornType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PlayerRebornType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PlayerRebornType, v)
	}
	*j = PlayerRebornType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTMetadata_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["attributes"]; !ok || v == nil {
		return fmt.Errorf("field attributes: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain NFTMetadata_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTMetadata_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerReborn) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["rebornLandId"]; !ok || v == nil {
		return fmt.Errorf("field rebornLandId: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain PlayerReborn
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerReborn(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["amountOfChange"]; !ok || v == nil {
		return fmt.Errorf("field amountOfChange: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["isMelandAI"]; !ok || v == nil {
		return fmt.Errorf("field isMelandAI: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["network"]; !ok || v == nil {
		return fmt.Errorf("field network: required")
	}
	if v, ok := raw["productId"]; !ok || v == nil {
		return fmt.Errorf("field productId: required")
	}
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId: required")
	}
	if v, ok := raw["tokenURL"]; !ok || v == nil {
		return fmt.Errorf("field tokenURL: required")
	}
	type Plain NFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFT(plain)
	return nil
}

type GetUserNFTsByUserIdAndAddressOutput struct {
	// Nfts corresponds to the JSON schema field "nfts".
	Nfts []NFT `json:"nfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsByUserIdAndAddressOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nfts"]; !ok || v == nil {
		return fmt.Errorf("field nfts: required")
	}
	type Plain GetUserNFTsByUserIdAndAddressOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsByUserIdAndAddressOutput(plain)
	return nil
}

type GetUserNFTsInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserNFTsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerRebornType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PlayerRebornType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PlayerRebornType_1, v)
	}
	*j = PlayerRebornType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTPlaceableTimeout) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["timeoutSec"]; !ok || v == nil {
		return fmt.Errorf("field timeoutSec: required")
	}
	type Plain NFTPlaceableTimeout
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTPlaceableTimeout(plain)
	return nil
}

type GetUserNFTsOutput struct {
	// 消息版本号
	Etag int `json:"etag"`

	// user all nfts
	Nfts []NFT `json:"nfts"`

	// NFT放置过期时间表
	PlaceableTimeouts []NFTPlaceableTimeout `json:"placeableTimeouts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nfts"]; !ok || v == nil {
		return fmt.Errorf("field nfts: required")
	}
	if v, ok := raw["placeableTimeouts"]; !ok || v == nil {
		return fmt.Errorf("field placeableTimeouts: required")
	}
	type Plain GetUserNFTsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsOutput(plain)
	return nil
}

type GetUserRecipesInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserRecipesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserRecipesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserRecipesInput(plain)
	return nil
}

type GetUserRecipesOutput struct {
	// RecipeIds corresponds to the JSON schema field "recipeIds".
	RecipeIds []string `json:"recipeIds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserRecipesOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["recipeIds"]; !ok || v == nil {
		return fmt.Errorf("field recipeIds: required")
	}
	type Plain GetUserRecipesOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserRecipesOutput(plain)
	return nil
}

type GetUserTrackInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserTrackInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserTrackInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserTrackInput(plain)
	return nil
}

type GetUserTrackOutput struct {
	// DitaminAmount corresponds to the JSON schema field "ditamin_amount".
	DitaminAmount int `json:"ditamin_amount"`

	// OccupiedLandNum corresponds to the JSON schema field "occupied_land_num".
	OccupiedLandNum int `json:"occupied_land_num"`

	// StakeVipname corresponds to the JSON schema field "stake_vipname".
	StakeVipname string `json:"stake_vipname"`

	// TicketLandNum corresponds to the JSON schema field "ticket_land_num".
	TicketLandNum int `json:"ticket_land_num"`

	// VipLandNum corresponds to the JSON schema field "vip_land_num".
	VipLandNum int `json:"vip_land_num"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserTrackOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ditamin_amount"]; !ok || v == nil {
		return fmt.Errorf("field ditamin_amount: required")
	}
	if v, ok := raw["occupied_land_num"]; !ok || v == nil {
		return fmt.Errorf("field occupied_land_num: required")
	}
	if v, ok := raw["stake_vipname"]; !ok || v == nil {
		return fmt.Errorf("field stake_vipname: required")
	}
	if v, ok := raw["ticket_land_num"]; !ok || v == nil {
		return fmt.Errorf("field ticket_land_num: required")
	}
	if v, ok := raw["vip_land_num"]; !ok || v == nil {
		return fmt.Errorf("field vip_land_num: required")
	}
	type Plain GetUserTrackOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserTrackOutput(plain)
	return nil
}

type GetUserWeb3ProfileInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserWeb3ProfileInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserWeb3ProfileInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserWeb3ProfileInput(plain)
	return nil
}

type GetUserWeb3ProfileOutput struct {
	// BlockchainAddress corresponds to the JSON schema field "blockchainAddress".
	BlockchainAddress string `json:"blockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserWeb3ProfileOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field blockchainAddress: required")
	}
	type Plain GetUserWeb3ProfileOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserWeb3ProfileOutput(plain)
	return nil
}

type HarvestInput struct {
	// 建造id
	BuildId int `json:"buildId"`

	// 地图id 为多地图准备
	MapId int `json:"mapId"`

	// 玩家id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HarvestInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildId"]; !ok || v == nil {
		return fmt.Errorf("field buildId: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain HarvestInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = HarvestInput(plain)
	return nil
}

type HarvestOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason"`

	// 是否成功
	Success bool `json:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HarvestOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	type Plain HarvestOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = HarvestOutput(plain)
	return nil
}

type Int32 int

type LandServiceAction string

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerKilled) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["killedLandId"]; !ok || v == nil {
		return fmt.Errorf("field killedLandId: required")
	}
	if v, ok := raw["lastDamage"]; !ok || v == nil {
		return fmt.Errorf("field lastDamage: required")
	}
	if v, ok := raw["targetId"]; !ok || v == nil {
		return fmt.Errorf("field targetId: required")
	}
	if v, ok := raw["targetName"]; !ok || v == nil {
		return fmt.Errorf("field targetName: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain PlayerKilled
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerKilled(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandServiceAction, v)
	}
	*j = LandServiceAction(v)
	return nil
}

const LandServiceActionBuild LandServiceAction = "Build"
const LandServiceActionCharged LandServiceAction = "Charged"
const LandServiceActionCollection LandServiceAction = "Collection"
const LandServiceActionGetAllBuildData LandServiceAction = "GetAllBuildData"
const LandServiceActionGetAllLandData LandServiceAction = "GetAllLandData"
const LandServiceActionHarvest LandServiceAction = "Harvest"
const LandServiceActionMintBattery LandServiceAction = "MintBattery"
const LandServiceActionRecycling LandServiceAction = "Recycling"

// 攻占地格 请求地格中产生效果的skill
type LandUsingSkillInput struct {
	// 消息版本号
	Etag int `json:"etag"`

	// 地格ID
	TileId int `json:"tileId"`

	// 攻占者ID
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandUsingSkillInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerDeath) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["deathLandId"]; !ok || v == nil {
		return fmt.Errorf("field deathLandId: required")
	}
	if v, ok := raw["killerId"]; !ok || v == nil {
		return fmt.Errorf("field killerId: required")
	}
	if v, ok := raw["killerName"]; !ok || v == nil {
		return fmt.Errorf("field killerName: required")
	}
	if v, ok := raw["lastDamage"]; !ok || v == nil {
		return fmt.Errorf("field lastDamage: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain PlayerDeath
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerDeath(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Skill) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level: required")
	}
	if v, ok := raw["skillId"]; !ok || v == nil {
		return fmt.Errorf("field skillId: required")
	}
	type Plain Skill
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Skill(plain)
	return nil
}

// 攻占地格 请求地格skill返回
type LandUsingSkillOutput struct {
	// 消息版本号
	Etag int `json:"etag"`

	// Skill List
	SkillList []Skill `json:"skillList"`

	// 地格ID
	TileId int `json:"tileId"`

	// 攻占者ID
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["skillList"]; !ok || v == nil {
		return fmt.Errorf("field skillList: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandUsingSkillOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillOutput(plain)
	return nil
}

type LearnUserRecipesInput struct {
	// RecipeIds corresponds to the JSON schema field "recipeIds".
	RecipeIds []string `json:"recipeIds"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LearnUserRecipesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["recipeIds"]; !ok || v == nil {
		return fmt.Errorf("field recipeIds: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LearnUserRecipesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LearnUserRecipesInput(plain)
	return nil
}

type LearnUserRecipesOutput map[string]interface{}

type MELDExchange2Ditamin struct {
	// AmountOfMELD corresponds to the JSON schema field "amountOfMELD".
	AmountOfMELD string `json:"amountOfMELD"`

	// DepositId corresponds to the JSON schema field "depositId".
	DepositId string `json:"depositId"`

	// DitaminAmount corresponds to the JSON schema field "ditaminAmount".
	DitaminAmount string `json:"ditaminAmount"`

	// 消息版本号
	Etag int `json:"etag"`

	// UserBlockchainAddress corresponds to the JSON schema field
	// "userBlockchainAddress".
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MELDExchange2Ditamin) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amountOfMELD"]; !ok || v == nil {
		return fmt.Errorf("field amountOfMELD: required")
	}
	if v, ok := raw["depositId"]; !ok || v == nil {
		return fmt.Errorf("field depositId: required")
	}
	if v, ok := raw["ditaminAmount"]; !ok || v == nil {
		return fmt.Errorf("field ditaminAmount: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain MELDExchange2Ditamin
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MELDExchange2Ditamin(plain)
	return nil
}

type MELDFutureExchangeRateChange struct {
	// 消息版本号
	Etag int `json:"etag"`

	// ExchangeRate corresponds to the JSON schema field "exchangeRate".
	ExchangeRate string `json:"exchangeRate"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MELDFutureExchangeRateChange) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["exchangeRate"]; !ok || v == nil {
		return fmt.Errorf("field exchangeRate: required")
	}
	type Plain MELDFutureExchangeRateChange
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MELDFutureExchangeRateChange(plain)
	return nil
}

type MELDFutureMint struct {
	// 花费多少ditamin
	DitaminAmount string `json:"ditaminAmount"`

	// 期货价值余额
	FutureAmount string `json:"futureAmount"`

	// MfId corresponds to the JSON schema field "mfId".
	MfId string `json:"mfId"`

	// 获得的用户钱包地址
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MELDFutureMint) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ditaminAmount"]; !ok || v == nil {
		return fmt.Errorf("field ditaminAmount: required")
	}
	if v, ok := raw["futureAmount"]; !ok || v == nil {
		return fmt.Errorf("field futureAmount: required")
	}
	if v, ok := raw["mfId"]; !ok || v == nil {
		return fmt.Errorf("field mfId: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain MELDFutureMint
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MELDFutureMint(plain)
	return nil
}

type MELDFutureRelease struct {
	// AmountOfMELD corresponds to the JSON schema field "amountOfMELD".
	AmountOfMELD string `json:"amountOfMELD"`

	// 消息版本号
	Etag int `json:"etag"`

	// MfId corresponds to the JSON schema field "mfId".
	MfId string `json:"mfId"`

	// UserBlockchainAddress corresponds to the JSON schema field
	// "userBlockchainAddress".
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MELDFutureRelease) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amountOfMELD"]; !ok || v == nil {
		return fmt.Errorf("field amountOfMELD: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["mfId"]; !ok || v == nil {
		return fmt.Errorf("field mfId: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain MELDFutureRelease
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MELDFutureRelease(plain)
	return nil
}

type MarketplaceTrade struct {
	// BuyerBlockchainAddress corresponds to the JSON schema field
	// "buyerBlockchainAddress".
	BuyerBlockchainAddress string `json:"buyerBlockchainAddress"`

	// ChainName corresponds to the JSON schema field "chainName".
	ChainName string `json:"chainName"`

	// 消息版本号
	Etag int `json:"etag"`

	// Nft corresponds to the JSON schema field "nft".
	Nft NFT `json:"nft"`

	// SellerBlockchainAddress corresponds to the JSON schema field
	// "sellerBlockchainAddress".
	SellerBlockchainAddress string `json:"sellerBlockchainAddress"`

	// TokenAmount corresponds to the JSON schema field "tokenAmount".
	TokenAmount string `json:"tokenAmount"`

	// TokenType corresponds to the JSON schema field "tokenType".
	TokenType string `json:"tokenType"`

	// Txn corresponds to the JSON schema field "txn".
	Txn string `json:"txn"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MarketplaceTrade) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buyerBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field buyerBlockchainAddress: required")
	}
	if v, ok := raw["chainName"]; !ok || v == nil {
		return fmt.Errorf("field chainName: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nft"]; !ok || v == nil {
		return fmt.Errorf("field nft: required")
	}
	if v, ok := raw["sellerBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field sellerBlockchainAddress: required")
	}
	if v, ok := raw["tokenAmount"]; !ok || v == nil {
		return fmt.Errorf("field tokenAmount: required")
	}
	if v, ok := raw["tokenType"]; !ok || v == nil {
		return fmt.Errorf("field tokenType: required")
	}
	if v, ok := raw["txn"]; !ok || v == nil {
		return fmt.Errorf("field txn: required")
	}
	type Plain MarketplaceTrade
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MarketplaceTrade(plain)
	return nil
}

type MelandServiceAction string

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionUITickInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data: required")
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId: required")
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	type Plain PkSessionUITickInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionUITickInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MelandServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MelandServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MelandServiceAction, v)
	}
	*j = MelandServiceAction(v)
	return nil
}

const MelandServiceActionBurnDitamin MelandServiceAction = "BurnDitamin"
const MelandServiceActionCanBuildNFT MelandServiceAction = "CanBuildNFT"
const MelandServiceActionCheckQuestionAnswer MelandServiceAction = "CheckQuestionAnswer"
const MelandServiceActionGetInitLandAttributions MelandServiceAction = "GetInitLandAttributions"
const MelandServiceActionGetQuestionResourcesByTypes MelandServiceAction = "GetQuestionResourcesByTypes"
const MelandServiceActionGetQuestionsByTypesRandom MelandServiceAction = "GetQuestionsByTypesRandom"
const MelandServiceActionGetUserIdByAddress MelandServiceAction = "GetUserIdByAddress"
const MelandServiceActionGetUserNFTs MelandServiceAction = "GetUserNFTs"
const MelandServiceActionGetUserTrack MelandServiceAction = "GetUserTrack"
const MelandServiceActionGetUserWeb3Profile MelandServiceAction = "GetUserWeb3Profile"
const MelandServiceActionSendMetaTx MelandServiceAction = "SendMetaTx"
const MelandServiceActionSendTx MelandServiceAction = "SendTx"

type MergeByRecipeInput struct {
	// 合成数量
	Amount int `json:"amount"`

	// 图鉴id
	RecipeId string `json:"recipeId"`

	// 合成的用户
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MergeByRecipeInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["recipeId"]; !ok || v == nil {
		return fmt.Errorf("field recipeId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain MergeByRecipeInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MergeByRecipeInput(plain)
	return nil
}

type MergeByRecipeOutput map[string]interface{}

type MintBatteryInput struct {
	// 赠送数量, 由前端传过来, 防止后端配表跟前端不一致时,
	// 出现问题
	GiftNum int `json:"giftNum"`

	// mint 数量
	Num int `json:"num"`

	// 用户数量
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintBatteryInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["giftNum"]; !ok || v == nil {
		return fmt.Errorf("field giftNum: required")
	}
	if v, ok := raw["num"]; !ok || v == nil {
		return fmt.Errorf("field num: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain MintBatteryInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintBatteryInput(plain)
	return nil
}

type MintBatteryOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason"`

	// 是否成功
	Success bool `json:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintBatteryOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	type Plain MintBatteryOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintBatteryOutput(plain)
	return nil
}

type MintNFTWithItemIdAndUserAddressInputQuality string

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionLoadSuccessInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId: required")
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	type Plain PkSessionLoadSuccessInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionLoadSuccessInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdAndUserAddressInputQuality) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MintNFTWithItemIdAndUserAddressInputQuality {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MintNFTWithItemIdAndUserAddressInputQuality, v)
	}
	*j = MintNFTWithItemIdAndUserAddressInputQuality(v)
	return nil
}

const MintNFTWithItemIdAndUserAddressInputQualityAdvanced MintNFTWithItemIdAndUserAddressInputQuality = "Advanced"
const MintNFTWithItemIdAndUserAddressInputQualityBasic MintNFTWithItemIdAndUserAddressInputQuality = "Basic"
const MintNFTWithItemIdAndUserAddressInputQualityEnhanced MintNFTWithItemIdAndUserAddressInputQuality = "Enhanced"
const MintNFTWithItemIdAndUserAddressInputQualitySuper MintNFTWithItemIdAndUserAddressInputQuality = "Super"
const MintNFTWithItemIdAndUserAddressInputQualityUltimate MintNFTWithItemIdAndUserAddressInputQuality = "Ultimate"

type MintNFTWithItemIdAndUserAddressInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount"`

	// Async corresponds to the JSON schema field "async".
	Async bool `json:"async"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId"`

	// Quality corresponds to the JSON schema field "quality".
	Quality *MintNFTWithItemIdAndUserAddressInputQuality `json:"quality,omitempty"`

	// QualityVal corresponds to the JSON schema field "qualityVal".
	QualityVal *string `json:"qualityVal,omitempty"`

	// UserAddress corresponds to the JSON schema field "userAddress".
	UserAddress string `json:"userAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdAndUserAddressInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["async"]; !ok || v == nil {
		return fmt.Errorf("field async: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["userAddress"]; !ok || v == nil {
		return fmt.Errorf("field userAddress: required")
	}
	type Plain MintNFTWithItemIdAndUserAddressInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithItemIdAndUserAddressInput(plain)
	return nil
}

type MintNFTWithItemIdAndUserAddressOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdAndUserAddressOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain MintNFTWithItemIdAndUserAddressOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithItemIdAndUserAddressOutput(plain)
	return nil
}

type MintNFTWithItemIdInputQuality string

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionDoQuestionOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["isCorrect"]; !ok || v == nil {
		return fmt.Errorf("field isCorrect: required")
	}
	type Plain PkSessionDoQuestionOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionDoQuestionOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdInputQuality) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MintNFTWithItemIdInputQuality {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MintNFTWithItemIdInputQuality, v)
	}
	*j = MintNFTWithItemIdInputQuality(v)
	return nil
}

const MintNFTWithItemIdInputQualityAdvanced MintNFTWithItemIdInputQuality = "Advanced"
const MintNFTWithItemIdInputQualityBasic MintNFTWithItemIdInputQuality = "Basic"
const MintNFTWithItemIdInputQualityEnhanced MintNFTWithItemIdInputQuality = "Enhanced"
const MintNFTWithItemIdInputQualitySuper MintNFTWithItemIdInputQuality = "Super"
const MintNFTWithItemIdInputQualityUltimate MintNFTWithItemIdInputQuality = "Ultimate"

type MintNFTWithItemIdInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount"`

	// Async corresponds to the JSON schema field "async".
	Async bool `json:"async"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId"`

	// 玩家所在的坐标landId,
	// 当mint场景是捡取掉落物时携带
	LandId int `json:"landId"`

	// Quality corresponds to the JSON schema field "quality".
	Quality *MintNFTWithItemIdInputQuality `json:"quality,omitempty"`

	// QualityVal corresponds to the JSON schema field "qualityVal".
	QualityVal *string `json:"qualityVal,omitempty"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["async"]; !ok || v == nil {
		return fmt.Errorf("field async: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain MintNFTWithItemIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithItemIdInput(plain)
	return nil
}

type MintNFTWithItemIdOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain MintNFTWithItemIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithItemIdOutput(plain)
	return nil
}

type MintNFTWithMetadataInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount"`

	// Async corresponds to the JSON schema field "async".
	Async bool `json:"async"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata NFTMetadata_1 `json:"metadata"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithMetadataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["async"]; !ok || v == nil {
		return fmt.Errorf("field async: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain MintNFTWithMetadataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithMetadataInput(plain)
	return nil
}

type MintNFTWithMetadataOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithMetadataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain MintNFTWithMetadataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithMetadataOutput(plain)
	return nil
}

const DitaminBurnSource_2_Exchange DitaminBurnSource_2 = "exchange"

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiBuildUpdateEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildDatas"]; !ok || v == nil {
		return fmt.Errorf("field buildDatas: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	type Plain MultiBuildUpdateEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiBuildUpdateEvent(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionDoQuestionInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId: required")
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	if v, ok := raw["questionId"]; !ok || v == nil {
		return fmt.Errorf("field questionId: required")
	}
	type Plain PkSessionDoQuestionInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionDoQuestionInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerInfoByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userIds"]; !ok || v == nil {
		return fmt.Errorf("field userIds: required")
	}
	type Plain MultiGetPlayerInfoByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerInfoByUserIdInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionAgainOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkRoomId"]; !ok || v == nil {
		return fmt.Errorf("field pkRoomId: required")
	}
	type Plain PkSessionAgainOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionAgainOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerInfoByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerInfos"]; !ok || v == nil {
		return fmt.Errorf("field playerInfos: required")
	}
	type Plain MultiGetPlayerInfoByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerInfoByUserIdOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionAgainInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId: required")
	}
	type Plain PkSessionAgainInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionAgainInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerUsingNftsByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userIds"]; !ok || v == nil {
		return fmt.Errorf("field userIds: required")
	}
	type Plain MultiGetPlayerUsingNftsByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerUsingNftsByUserIdInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PageMeta) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["count"]; !ok || v == nil {
		return fmt.Errorf("field count: required")
	}
	type Plain PageMeta
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PageMeta(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserUsingNft) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	if v, ok := raw["usingNfts"]; !ok || v == nil {
		return fmt.Errorf("field usingNfts: required")
	}
	type Plain UserUsingNft
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserUsingNft(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPUserType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPUserType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPUserType_1, v)
	}
	*j = PVPUserType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerUsingNftsByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["UserUsingNfts"]; !ok || v == nil {
		return fmt.Errorf("field UserUsingNfts: required")
	}
	type Plain MultiGetPlayerUsingNftsByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerUsingNftsByUserIdOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPType, v)
	}
	*j = PVPType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiLandDataUpdateEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["lands"]; !ok || v == nil {
		return fmt.Errorf("field lands: required")
	}
	type Plain MultiLandDataUpdateEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiLandDataUpdateEvent(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPSubscriptionEvent) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPSubscriptionEvent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPSubscriptionEvent, v)
	}
	*j = PVPSubscriptionEvent(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecyclingInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildId"]; !ok || v == nil {
		return fmt.Errorf("field buildId: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId: required")
	}
	type Plain RecyclingInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecyclingInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPServiceAction, v)
	}
	*j = PVPServiceAction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiRecyclingEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["recyclingInfos"]; !ok || v == nil {
		return fmt.Errorf("field recyclingInfos: required")
	}
	type Plain MultiRecyclingEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiRecyclingEvent(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPRoomReadyInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	if v, ok := raw["pvpRoomId"]; !ok || v == nil {
		return fmt.Errorf("field pvpRoomId: required")
	}
	type Plain PVPRoomReadyInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPRoomReadyInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecipeInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain RecipeInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecipeInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPRoomPreLeaveOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["canLeave"]; !ok || v == nil {
		return fmt.Errorf("field canLeave: required")
	}
	type Plain PVPRoomPreLeaveOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPRoomPreLeaveOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiUpdateUserNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["fromLandId"]; !ok || v == nil {
		return fmt.Errorf("field fromLandId: required")
	}
	if v, ok := raw["nfts"]; !ok || v == nil {
		return fmt.Errorf("field nfts: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain MultiUpdateUserNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiUpdateUserNFT(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPRoomPreLeaveInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	if v, ok := raw["roomId"]; !ok || v == nil {
		return fmt.Errorf("field roomId: required")
	}
	type Plain PVPRoomPreLeaveInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPRoomPreLeaveInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPPKSessionStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPPKSessionStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPPKSessionStatus, v)
	}
	*j = PVPPKSessionStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitTypes) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitTypes {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitTypes, v)
	}
	*j = NFTTraitTypes(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchLeaveOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["succese"]; !ok || v == nil {
		return fmt.Errorf("field succese: required")
	}
	type Plain PVPMatchLeaveOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchLeaveOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchLeaveInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	type Plain PVPMatchLeaveInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchLeaveInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchEnterOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["succese"]; !ok || v == nil {
		return fmt.Errorf("field succese: required")
	}
	type Plain PVPMatchEnterOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchEnterOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchEnterInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	type Plain PVPMatchEnterInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchEnterInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPEndType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPEndType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPEndType, v)
	}
	*j = PVPEndType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitWearingPosition) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitWearingPosition {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitWearingPosition, v)
	}
	*j = NFTTraitWearingPosition(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitType, v)
	}
	*j = NFTTraitType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitRarity) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitRarity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitRarity, v)
	}
	*j = NFTTraitRarity(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitQuality) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitQuality {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitQuality, v)
	}
	*j = NFTTraitQuality(v)
	return nil
}

type MultiBuildUpdateEvent struct {
	// 建造物信息
	BuildDatas []BuildData `json:"buildDatas"`

	// 消息版本号
	Etag int `json:"etag"`
}

type MultiGetPlayerInfoByUserIdInput struct {
	// UserIds corresponds to the JSON schema field "userIds".
	UserIds []string `json:"userIds"`
}

type MultiGetPlayerInfoByUserIdOutput struct {
	// PlayerInfos corresponds to the JSON schema field "playerInfos".
	PlayerInfos []PlayerInfo `json:"playerInfos"`
}

type MultiGetPlayerUsingNftsByUserIdInput struct {
	// UserIds corresponds to the JSON schema field "userIds".
	UserIds []string `json:"userIds"`
}

type MultiGetPlayerUsingNftsByUserIdOutput struct {
	// UserUsingNfts corresponds to the JSON schema field "UserUsingNfts".
	UserUsingNfts []UserUsingNft `json:"UserUsingNfts"`
}

type MultiLandDataUpdateEvent struct {
	// 消息版本号
	Etag int `json:"etag"`

	// Lands corresponds to the JSON schema field "lands".
	Lands []LandData `json:"lands"`
}

type MultiRecyclingEvent struct {
	// 消息版本号
	Etag int `json:"etag"`

	// RecyclingInfos corresponds to the JSON schema field "recyclingInfos".
	RecyclingInfos []RecyclingInfo `json:"recyclingInfos"`
}

type MultiUpdateUserNFT struct {
	// 消息版本号
	Etag int `json:"etag"`

	// 来源坐标
	// 当捡取时携带且不为0
	FromLandId int `json:"fromLandId"`

	// 来源合成图鉴
	FromRecipeInfo *RecipeInfo `json:"fromRecipeInfo,omitempty"`

	// NFT信息
	Nfts []NFT `json:"nfts"`

	// 接收NFT的用户钱包地址
	RecipientBlockchainAddress *string `json:"recipientBlockchainAddress,omitempty"`

	// 发送NFT的用户钱包地址
	SenderBlockchainAddress *string `json:"senderBlockchainAddress,omitempty"`

	// 区块链交易hash
	Txn *string `json:"txn,omitempty"`

	// 归属用户id
	UserId string `json:"userId"`
}

type NFT struct {
	// NFT address
	Address string `json:"address"`

	// NFT amount
	Amount int `json:"amount"`

	// NFT 变化量
	// 默认值为0, 当某一个事件发出时,
	// 若为n<0则表示此次事件导致的nft数量减少n,
	// n>0则表示此次事件导致的nft数量增加n
	AmountOfChange int `json:"amountOfChange"`

	// NFT id
	Id string `json:"id"`

	// 该NFT是否是Meland.ai官方NFT
	IsMelandAI bool `json:"isMelandAI"`

	// 只有当isMelandAI为true时, 才存在, 否则为空字符串
	ItemId string `json:"itemId"`

	// NFT metadata info
	// 如果非第三方则必须有metadata
	// 目前的实现是, 如果是第三方NFT, 则metadata为空,
	// 直接将tokenURL返回给前端解析即可.
	// example:
	// https://nftmetadata-service-release.melandworld.com/placeable/80000031/1
	Metadata *NFTMetadata_1 `json:"metadata,omitempty"`

	// 描述当前nft存储于那条链上
	Network string `json:"network"`

	// product Id
	ProductId string `json:"productId"`

	// NFT token id
	TokenId string `json:"tokenId"`

	// NFT metadata url
	// https://nftmetadata-service-release.melandworld.com/placeable/80000031/1
	TokenURL string `json:"tokenURL"`
}

// NFTAttribute 为产品定义的每个NFT的属性.
type NFTAttribute struct {
	// DisplayType corresponds to the JSON schema field "display_type".
	DisplayType *string `json:"display_type,omitempty"`

	// TraitType corresponds to the JSON schema field "trait_type".
	TraitType string `json:"trait_type"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value"`
}

// NFT metadata源信息
// https://docs.opensea.io/docs/metadata-standards
type NFTMetadata_1 struct {
	// NFT gif animation url
	AnimationUrl *string `json:"animation_url,omitempty"`

	// NFT的额外属性.
	Attributes []NFTAttribute `json:"attributes"`

	// BackgroundColor corresponds to the JSON schema field "background_color".
	BackgroundColor *string `json:"background_color,omitempty"`

	// NFT description
	Description string `json:"description"`

	// NFT 扩展url
	// 有扩展URL的NFT社区会实现规范用户点击进行跳转。
	ExternalUrl *string `json:"external_url,omitempty"`

	// NFT image data.
	Image *string `json:"image,omitempty"`

	// ImageData corresponds to the JSON schema field "image_data".
	ImageData *string `json:"image_data,omitempty"`

	// ImageUrl corresponds to the JSON schema field "image_url".
	ImageUrl *string `json:"image_url,omitempty"`

	// NFT的原始数据. 只有meland.ai的NFT才会携带
	// 基于策划的表格配置生成.
	MelandAttributes []MelandAttribute `json:"melandAttributes,omitempty"`

	// NFT name
	Name string `json:"name"`

	// Youtube video url
	YoutubeUrl *string `json:"youtube_url,omitempty"`
}

// NFT放置过期时间结构体
type NFTPlaceableTimeout struct {
	// NFT Id
	NftId string `json:"nftId"`

	// 名字（是否唯一）
	TimeoutSec int `json:"timeoutSec"`
}

// 核心技能id
type NFTTraitCoreSkillId interface{}

type NFTTraitPlaceableLands string

const NFTTraitPlaceableLandsOccupied NFTTraitPlaceableLands = "Occupied"
const NFTTraitPlaceableLandsTicket NFTTraitPlaceableLands = "Ticket"
const NFTTraitPlaceableLandsVIP NFTTraitPlaceableLands = "VIP"

type NFTTraitQuality string

const NFTTraitQualityAdvanced NFTTraitQuality = "Advanced"
const NFTTraitQualityBasic NFTTraitQuality = "Basic"
const NFTTraitQualityEnhanced NFTTraitQuality = "Enhanced"
const NFTTraitQualitySuper NFTTraitQuality = "Super"
const NFTTraitQualityUltimate NFTTraitQuality = "Ultimate"

type NFTTraitRarity string

const NFTTraitRarityCommon NFTTraitRarity = "common"
const NFTTraitRarityEpic NFTTraitRarity = "epic"
const NFTTraitRarityMythic NFTTraitRarity = "mythic"
const NFTTraitRarityRare NFTTraitRarity = "rare"
const NFTTraitRarityUnique NFTTraitRarity = "unique"

type NFTTraitSkillLevel interface{}

type NFTTraitType string

const NFTTraitTypeBow NFTTraitType = "Bow"
const NFTTraitTypeChestArmor NFTTraitType = "Chest Armor"
const NFTTraitTypeConsumable NFTTraitType = "Consumable"
const NFTTraitTypeDagger NFTTraitType = "Dagger"
const NFTTraitTypeFeetArmor NFTTraitType = "Feet Armor"
const NFTTraitTypeHandsArmor NFTTraitType = "Hands Armor"
const NFTTraitTypeHeadArmor NFTTraitType = "Head Armor"
const NFTTraitTypeLegsArmor NFTTraitType = "Legs Armor"
const NFTTraitTypeMaterial NFTTraitType = "Material"
const NFTTraitTypeMysteryBox NFTTraitType = "MysteryBox"
const NFTTraitTypePlaceable NFTTraitType = "Placeable"
const NFTTraitTypeSpear NFTTraitType = "Spear"
const NFTTraitTypeSword NFTTraitType = "Sword"
const NFTTraitTypeWearable NFTTraitType = "Wearable"

type NFTTraitTypes string

const NFTTraitTypesAttack NFTTraitTypes = "Attack"
const NFTTraitTypesAttackSpeed NFTTraitTypes = "Attack Speed"
const NFTTraitTypesCoreSkillId NFTTraitTypes = "CoreSkillId"
const NFTTraitTypesCreator NFTTraitTypes = "Creator"
const NFTTraitTypesCritDamage NFTTraitTypes = "Crit Damage"
const NFTTraitTypesCritPoints NFTTraitTypes = "Crit Points"
const NFTTraitTypesDefence NFTTraitTypes = "Defence"
const NFTTraitTypesDodgePoints NFTTraitTypes = "Dodge Points"
const NFTTraitTypesFertilize NFTTraitTypes = "Fertilize"
const NFTTraitTypesGender NFTTraitTypes = "Gender"
const NFTTraitTypesGetBuff NFTTraitTypes = "Get Buff"
const NFTTraitTypesHPRecovery NFTTraitTypes = "HP Recovery"
const NFTTraitTypesHitPoints NFTTraitTypes = "Hit Points"
const NFTTraitTypesLearnRecipe NFTTraitTypes = "Learn Recipe"
const NFTTraitTypesMaxHP NFTTraitTypes = "MaxHP"
const NFTTraitTypesMoveSpeed NFTTraitTypes = "Move Speed"
const NFTTraitTypesOccupyLand NFTTraitTypes = "Occupy Land"
const NFTTraitTypesPlaceableLands NFTTraitTypes = "Placeable Lands"
const NFTTraitTypesQuality NFTTraitTypes = "Quality"
const NFTTraitTypesRarity NFTTraitTypes = "Rarity"
const NFTTraitTypesRequiresLevel NFTTraitTypes = "Requires level"
const NFTTraitTypesRestoreHP NFTTraitTypes = "Restore HP"
const NFTTraitTypesSeries NFTTraitTypes = "Series"
const NFTTraitTypesSkillLevel NFTTraitTypes = "SkillLevel"
const NFTTraitTypesSowSeeds NFTTraitTypes = "Sow Seeds"
const NFTTraitTypesType NFTTraitTypes = "Type"
const NFTTraitTypesWearingPosition NFTTraitTypes = "Wearing Position"

type NFTTraitWearingPosition string

const NFTTraitWearingPositionGloves NFTTraitWearingPosition = "Gloves"
const NFTTraitWearingPositionHead NFTTraitWearingPosition = "Head"
const NFTTraitWearingPositionLowerBody NFTTraitWearingPosition = "Lower Body"
const NFTTraitWearingPositionShoes NFTTraitWearingPosition = "Shoes"
const NFTTraitWearingPositionUpperBody NFTTraitWearingPosition = "Upper Body"

type PVPEndType string

const PVPEndTypeEndTypeTie PVPEndType = "endTypeTie"
const PVPEndTypeEndTypeWin PVPEndType = "endTypeWin"

type PVPMatchEnterInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`
}

type PVPMatchEnterOutput struct {
	// Succese corresponds to the JSON schema field "succese".
	Succese bool `json:"succese"`
}

type PVPMatchLeaveInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`
}

type PVPMatchLeaveOutput struct {
	// Succese corresponds to the JSON schema field "succese".
	Succese bool `json:"succese"`
}

type PVPPKSessionStatus string

const PVPPKSessionStatusEnded PVPPKSessionStatus = "ended"
const PVPPKSessionStatusPreloading PVPPKSessionStatus = "preloading"
const PVPPKSessionStatusStarted PVPPKSessionStatus = "started"

type PVPPlayer struct {
	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Type corresponds to the JSON schema field "type".
	Type PVPUserType `json:"type"`
}

type PVPRoomPreLeaveInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`

	// RoomId corresponds to the JSON schema field "roomId".
	RoomId string `json:"roomId"`
}

type PVPRoomPreLeaveOutput struct {
	// CanLeave corresponds to the JSON schema field "canLeave".
	CanLeave bool `json:"canLeave"`
}

type PVPRoomReadyInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`

	// PvpRoomId corresponds to the JSON schema field "pvpRoomId".
	PvpRoomId string `json:"pvpRoomId"`
}

type PVPRoomReadyOutput map[string]interface{}

type PVPServiceAction string

const PVPServiceActionCreatePVPRoom PVPServiceAction = "CreatePVPRoom"
const PVPServiceActionGetCurrentPkSessionId PVPServiceAction = "GetCurrentPkSessionId"
const PVPServiceActionGetPlayerPvpProfile PVPServiceAction = "GetPlayerPvpProfile"
const PVPServiceActionGetPlayerPvpRank PVPServiceAction = "GetPlayerPvpRank"
const PVPServiceActionGetPvpHistory PVPServiceAction = "GetPvpHistory"
const PVPServiceActionPVPMatchEnter PVPServiceAction = "PVPMatchEnter"
const PVPServiceActionPVPMatchLeave PVPServiceAction = "PVPMatchLeave"
const PVPServiceActionPVPRoomPreLeave PVPServiceAction = "PVPRoomPreLeave"
const PVPServiceActionPVPRoomReady PVPServiceAction = "PVPRoomReady"
const PVPServiceActionPkSessionAgain PVPServiceAction = "PkSessionAgain"
const PVPServiceActionPkSessionDoQuestion PVPServiceAction = "PkSessionDoQuestion"
const PVPServiceActionPkSessionLoadSuccess PVPServiceAction = "PkSessionLoadSuccess"
const PVPServiceActionPkSessionUITick PVPServiceAction = "PkSessionUITick"
const PVPServiceActionPvpSurrender PVPServiceAction = "PvpSurrender"

type PVPSubscriptionEvent string

const PVPSubscriptionEventPVPMatchBegin PVPSubscriptionEvent = "PVPMatchBegin"

type PVPType string

const PVPTypePvpTypeMatch PVPType = "pvpTypeMatch"
const PVPTypePvpTypePk PVPType = "pvpTypePk"

type PVPUserType string

const PVPUserTypeGuest PVPUserType = "guest"
const PVPUserTypeUser PVPUserType = "user"

type PVPUserType_1 string

const PVPUserType_1_Guest PVPUserType_1 = "guest"
const PVPUserType_1_User PVPUserType_1 = "user"

type PageMeta struct {
	// Count corresponds to the JSON schema field "count".
	Count int `json:"count"`
}

type PkSessionAgainInput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId"`
}

type PkSessionAgainOutput struct {
	// PkRoomId corresponds to the JSON schema field "pkRoomId".
	PkRoomId string `json:"pkRoomId"`
}

type PkSessionDoQuestionInput struct {
	// AnswerSequentialMatch corresponds to the JSON schema field
	// "answerSequentialMatch".
	AnswerSequentialMatch []string `json:"answerSequentialMatch,omitempty"`

	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId"`

	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`

	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId"`
}

type PkSessionDoQuestionOutput struct {
	// IsCorrect corresponds to the JSON schema field "isCorrect".
	IsCorrect bool `json:"isCorrect"`
}

type PkSessionLoadSuccessInput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId"`

	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`
}

type PkSessionLoadSuccessOutput map[string]interface{}

type PkSessionUITickInput struct {
	// Data corresponds to the JSON schema field "data".
	Data string `json:"data"`

	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId"`

	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`
}

type PkSessionUITickOutput map[string]interface{}

type PlayerAvatar struct {
	// Cid corresponds to the JSON schema field "cid".
	Cid int `json:"cid"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId"`

	// NftJson corresponds to the JSON schema field "nftJson".
	NftJson string `json:"nftJson"`

	// Pos corresponds to the JSON schema field "pos".
	Pos int `json:"pos"`
}

// 玩家死亡事件, 当玩家死亡时触发
type PlayerDeath struct {
	// 玩家死亡的附近landId
	DeathLandId int `json:"deathLandId"`

	// 造成玩家死亡的生物或用户id
	KillerId string `json:"killerId"`

	// 造成玩家死亡的生物或用户名称
	KillerName string `json:"killerName"`

	// 最后造成死亡的数值
	LastDamage float64 `json:"lastDamage"`

	// 死亡的用户id
	UserId string `json:"userId"`
}

type PlayerInfo struct {
	// CurExp corresponds to the JSON schema field "curExp".
	CurExp int `json:"curExp"`

	// CurHp corresponds to the JSON schema field "curHp".
	CurHp int `json:"curHp"`

	// Feature corresponds to the JSON schema field "feature".
	Feature string `json:"feature"`

	// Icon corresponds to the JSON schema field "icon".
	Icon string `json:"icon"`

	// Level corresponds to the JSON schema field "level".
	Level int `json:"level"`

	// PlayerName corresponds to the JSON schema field "playerName".
	PlayerName string `json:"playerName"`

	// 角色cid (男性 1001 / 女性 1002)
	RoleCId int `json:"roleCId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type PlayerItemSlot struct {
	// Level corresponds to the JSON schema field "level".
	Level int `json:"level"`

	// Position corresponds to the JSON schema field "position".
	Position int `json:"position"`
}

// 玩家击杀怪物
type PlayerKilled struct {
	// 怪物被击杀的坐标
	KilledLandId int `json:"killedLandId"`

	// 最后一击的伤害
	LastDamage float64 `json:"lastDamage"`

	// 击杀的目标id
	TargetId string `json:"targetId"`

	// 击杀的目标名称
	TargetName string `json:"targetName"`

	// 用户id
	UserId string `json:"userId"`
}

// 玩家重生事件, 当玩家重生时, 会触发此事件
type PlayerReborn struct {
	// 重生的地格id
	RebornLandId int `json:"rebornLandId"`

	// 玩家重生类型
	Type PlayerRebornType_1 `json:"type"`

	// 重生的玩家id
	UserId string `json:"userId"`
}

type PlayerRebornType string

const PlayerRebornTypeInPlace PlayerRebornType = "in_place"
const PlayerRebornTypeMainCity PlayerRebornType = "main_city"

type PlayerRebornType_1 string

const PlayerRebornType_1_InPlace PlayerRebornType_1 = "in_place"
const PlayerRebornType_1_MainCity PlayerRebornType_1 = "main_city"

type Prefetch struct {
	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId"`

	// QuestionType corresponds to the JSON schema field "questionType".
	QuestionType QuestionType `json:"questionType"`

	// Resources corresponds to the JSON schema field "resources".
	Resources []string `json:"resources"`
}

type PvpHistory struct {
	// EndType corresponds to the JSON schema field "endType".
	EndType string `json:"endType"`

	// Loser corresponds to the JSON schema field "loser".
	Loser string `json:"loser"`

	// LoserName corresponds to the JSON schema field "loserName".
	LoserName string `json:"loserName"`

	// LoserScore corresponds to the JSON schema field "loserScore".
	LoserScore int `json:"loserScore"`

	// PvpType corresponds to the JSON schema field "pvpType".
	PvpType string `json:"pvpType"`

	// ScoreOffset corresponds to the JSON schema field "scoreOffset".
	ScoreOffset int `json:"scoreOffset"`

	// TimeSec corresponds to the JSON schema field "timeSec".
	TimeSec int `json:"timeSec"`

	// Winner corresponds to the JSON schema field "winner".
	Winner string `json:"winner"`

	// WinnerName corresponds to the JSON schema field "winnerName".
	WinnerName string `json:"winnerName"`

	// WinnerScore corresponds to the JSON schema field "winnerScore".
	WinnerScore int `json:"winnerScore"`
}

type PvpPlayerProfile struct {
	// Avatars corresponds to the JSON schema field "avatars".
	Avatars []PlayerAvatar `json:"avatars"`

	// BaseInfo corresponds to the JSON schema field "baseInfo".
	BaseInfo PlayerInfo `json:"baseInfo"`

	// ItemSlots corresponds to the JSON schema field "itemSlots".
	ItemSlots []PlayerItemSlot `json:"itemSlots"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`

	// Score corresponds to the JSON schema field "score".
	Score int `json:"score"`
}

type PvpPlayerRank struct {
	// Avatars corresponds to the JSON schema field "avatars".
	Avatars []PlayerAvatar `json:"avatars"`

	// BaseInfo corresponds to the JSON schema field "baseInfo".
	BaseInfo PlayerInfo `json:"baseInfo"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`

	// Rank corresponds to the JSON schema field "rank".
	Rank int `json:"rank"`

	// Score corresponds to the JSON schema field "score".
	Score int `json:"score"`
}

type PvpSurrenderInput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`
}

type PvpSurrenderOutput struct {
	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success"`
}

type Question struct {
	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// StructJSON corresponds to the JSON schema field "structJSON".
	StructJSON string `json:"structJSON"`
}

type QuestionType string

const QuestionTypeAdjustClock QuestionType = "AdjustClock"
const QuestionTypeBlockCompute QuestionType = "BlockCompute"
const QuestionTypeCageShuffle QuestionType = "CageShuffle"
const QuestionTypeCardMemory QuestionType = "CardMemory"
const QuestionTypeCuttingArt QuestionType = "CuttingArt"
const QuestionTypeHitBrick QuestionType = "HitBrick"
const QuestionTypeMatchingMouse QuestionType = "MatchingMouse"
const QuestionTypeQuickFlashMemory QuestionType = "QuickFlashMemory"
const QuestionTypeReverseMemory QuestionType = "ReverseMemory"
const QuestionTypeRotatingSilhouette QuestionType = "RotatingSilhouette"
const QuestionTypeSequenceBalloon QuestionType = "SequenceBalloon"
const QuestionTypeSingleChoice QuestionType = "SingleChoice"

type QuestionType_1 string

const QuestionType_1_AdjustClock QuestionType_1 = "AdjustClock"
const QuestionType_1_BlockCompute QuestionType_1 = "BlockCompute"
const QuestionType_1_CageShuffle QuestionType_1 = "CageShuffle"
const QuestionType_1_CardMemory QuestionType_1 = "CardMemory"
const QuestionType_1_CuttingArt QuestionType_1 = "CuttingArt"
const QuestionType_1_HitBrick QuestionType_1 = "HitBrick"
const QuestionType_1_MatchingMouse QuestionType_1 = "MatchingMouse"
const QuestionType_1_QuickFlashMemory QuestionType_1 = "QuickFlashMemory"
const QuestionType_1_ReverseMemory QuestionType_1 = "ReverseMemory"
const QuestionType_1_RotatingSilhouette QuestionType_1 = "RotatingSilhouette"
const QuestionType_1_SequenceBalloon QuestionType_1 = "SequenceBalloon"
const QuestionType_1_SingleChoice QuestionType_1 = "SingleChoice"

type RecipeInfo struct {
	// 图鉴id
	Id string `json:"id"`

	// 图鉴名称
	Name string `json:"name"`
}

type RecyclingInfo struct {
	// BuildId corresponds to the JSON schema field "buildId".
	BuildId int `json:"buildId"`

	// MapId corresponds to the JSON schema field "mapId".
	MapId int `json:"mapId"`
}

type RecyclingInput struct {
	// 建造Id
	BuildId int `json:"buildId"`

	// 地图id 为多地图准备
	MapId int `json:"mapId"`

	// 玩家id
	UserId string `json:"userId"`
}

type RecyclingOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason"`

	// 是否成功
	Success bool `json:"success"`
}

type SceneDynamicServiceAction string

const SceneDynamicServiceActionStartServer SceneDynamicServiceAction = "StartServer"

type SendMetaTxInput struct {
	// Data corresponds to the JSON schema field "data".
	Data string `json:"data"`

	// From corresponds to the JSON schema field "from".
	From string `json:"from"`

	// Gas corresponds to the JSON schema field "gas".
	Gas float64 `json:"gas"`

	// Nonce corresponds to the JSON schema field "nonce".
	Nonce string `json:"nonce"`

	// Signature corresponds to the JSON schema field "signature".
	Signature string `json:"signature"`

	// To corresponds to the JSON schema field "to".
	To string `json:"to"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value"`
}

type SendMetaTxOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

type SendTxInput struct {
	// Data corresponds to the JSON schema field "data".
	Data string `json:"data"`

	// Gas corresponds to the JSON schema field "gas".
	Gas float64 `json:"gas"`

	// To corresponds to the JSON schema field "to".
	To string `json:"to"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value"`
}

type SendTxOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

type Sex string

const SexFEMALE Sex = "FEMALE"
const SexMALE Sex = "MALE"

type Sex_1 string

const Sex_1_FEMALE Sex_1 = "FEMALE"
const Sex_1_MALE Sex_1 = "MALE"

type Skill struct {
	// skill level
	Level int `json:"level"`

	// skill Id,  only key
	SkillId int `json:"skillId"`
}

type SmapleNFT struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata NFTMetadata_1 `json:"metadata"`

	// TokenId corresponds to the JSON schema field "tokenId".
	TokenId string `json:"tokenId"`
}

type StartServerInput struct {
	// Args corresponds to the JSON schema field "args".
	Args string `json:"args"`

	// Envs corresponds to the JSON schema field "envs".
	Envs string `json:"envs"`
}

type StartServerOutput struct {
	// ServerAppId corresponds to the JSON schema field "serverAppId".
	ServerAppId string `json:"serverAppId"`
}

type SubscriptionEvent string

const SubscriptionEventCloseServer SubscriptionEvent = "CloseServer"
const SubscriptionEventDitaminBurn SubscriptionEvent = "DitaminBurn"
const SubscriptionEventDitaminProduce SubscriptionEvent = "DitaminProduce"
const SubscriptionEventFinishQuestion SubscriptionEvent = "FinishQuestion"
const SubscriptionEventMELDExchange2Ditamin SubscriptionEvent = "MELDExchange2Ditamin"
const SubscriptionEventMELDFutureExchangeRateChange SubscriptionEvent = "MELDFutureExchangeRateChange"
const SubscriptionEventMELDFutureMint SubscriptionEvent = "MELDFutureMint"
const SubscriptionEventMELDFutureRelease SubscriptionEvent = "MELDFutureRelease"
const SubscriptionEventMarketplaceTrade SubscriptionEvent = "MarketplaceTrade"
const SubscriptionEventMultiBuildUpdateEvent SubscriptionEvent = "MultiBuildUpdateEvent"
const SubscriptionEventMultiLandDataUpdateEvent SubscriptionEvent = "MultiLandDataUpdateEvent"
const SubscriptionEventMultiRecyclingEvent SubscriptionEvent = "MultiRecyclingEvent"
const SubscriptionEventMultiUpdateUserNFT SubscriptionEvent = "MultiUpdateUserNFT"
const SubscriptionEventPlayerDeath SubscriptionEvent = "PlayerDeath"
const SubscriptionEventPlayerKilled SubscriptionEvent = "PlayerKilled"
const SubscriptionEventPlayerReborn SubscriptionEvent = "PlayerReborn"
const SubscriptionEventUnloadEquipment SubscriptionEvent = "UnloadEquipment"
const SubscriptionEventUpdateUpcomingUses SubscriptionEvent = "UpdateUpcomingUses"
const SubscriptionEventUpdateUserNFT SubscriptionEvent = "UpdateUserNFT"
const SubscriptionEventUseConsumabled SubscriptionEvent = "UseConsumabled"
const SubscriptionEventUseEquipment SubscriptionEvent = "UseEquipment"

type TemporaryToken struct {
	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt string `json:"createdAt"`

	// ExpiredAt corresponds to the JSON schema field "expiredAt".
	ExpiredAt string `json:"expiredAt"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// TemporaryTokenExtraInfo corresponds to the JSON schema field
	// "temporaryTokenExtraInfo".
	TemporaryTokenExtraInfo *TemporaryTokenExtraInfo `json:"temporaryTokenExtraInfo,omitempty"`

	// Token corresponds to the JSON schema field "token".
	Token string `json:"token"`

	// UpdatedAt corresponds to the JSON schema field "updatedAt".
	UpdatedAt string `json:"updatedAt"`

	// UsedAt corresponds to the JSON schema field "usedAt".
	UsedAt *string `json:"usedAt,omitempty"`
}

type TemporaryTokenExtraInfo struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type UnloadEquipment struct {
	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId"`

	// 游戏角色id
	PlayerId string `json:"playerId"`

	// 用户id
	UserId string `json:"userId"`
}

type UpdateUpcomingUses struct {
	// Number corresponds to the JSON schema field "number".
	Number int `json:"number"`
}

// 更新用户的NFT
// 可能是添加或者数量变更.
type UpdateUserNFT struct {
	// 消息版本号
	Etag int `json:"etag"`

	// 来源坐标
	// 当捡取时携带且不为0
	FromLandId int `json:"fromLandId"`

	// NFT信息
	Nft NFT `json:"nft"`

	// 接收NFT的用户钱包地址
	RecipientBlockchainAddress *string `json:"recipientBlockchainAddress,omitempty"`

	// 发送NFT的用户钱包地址
	SenderBlockchainAddress *string `json:"senderBlockchainAddress,omitempty"`

	// 区块链交易hash
	Txn *string `json:"txn,omitempty"`

	// 归属用户id
	UserId string `json:"userId"`
}

type UpgradePlayerItemSlotsInput struct {
	// ItemSlots corresponds to the JSON schema field "itemSlots".
	ItemSlots []PlayerItemSlot `json:"itemSlots"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type UpgradePlayerItemSlotsOutput struct {
	// 是否成功
	Success bool `json:"success"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type UseConsumableInput struct {
	// 消耗品的数量
	Amount int `json:"amount"`

	// 使用消耗品的动态参数
	Args *string `json:"args,omitempty"`

	// 使用消耗品的坐标
	LandId int `json:"landId"`

	// 消耗品的id
	NftId string `json:"nftId"`

	// 使用消耗品的用户
	UserId string `json:"userId"`
}

type UseConsumableOutput struct {
	// 消耗品的数量
	Amount int `json:"amount"`

	// 消耗品的id
	NftId string `json:"nftId"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success"`

	// 使用消耗品的用户
	UserId string `json:"userId"`
}

type UseConsumabled struct {
	// 消耗品的数量
	Amount int `json:"amount"`

	// 消息版本号
	Etag int `json:"etag"`

	// 使用消耗品的坐标
	LandId int `json:"landId"`

	// Nft corresponds to the JSON schema field "nft".
	Nft NFT `json:"nft"`

	// 使用消耗品的用户
	UserId string `json:"userId"`
}

type UseEquipment struct {
	// 装备位置 对时装和装备有效
	AvatarPos int `json:"avatarPos"`

	// Cid corresponds to the JSON schema field "cid".
	Cid int `json:"cid"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId"`

	// 游戏角色id
	PlayerId string `json:"playerId"`

	// 用户id
	UserId string `json:"userId"`
}

type UseMELDInput struct {
	// 使用金额
	Amount int `json:"amount"`

	// 用户id
	UserId string `json:"userId"`
}

type UseMELDOutput struct {
	// 如果燃烧失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason"`

	// 是否成功
	Success bool `json:"success"`
}

type User struct {
	// Avatar corresponds to the JSON schema field "avatar".
	Avatar string `json:"avatar"`

	// Email corresponds to the JSON schema field "email".
	Email string `json:"email"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Mobile corresponds to the JSON schema field "mobile".
	Mobile string `json:"mobile"`

	// Nickname corresponds to the JSON schema field "nickname".
	Nickname string `json:"nickname"`

	// Realname corresponds to the JSON schema field "realname".
	Realname string `json:"realname"`

	// SchoolId corresponds to the JSON schema field "schoolId".
	SchoolId string `json:"schoolId"`

	// Sex corresponds to the JSON schema field "sex".
	Sex Sex_1 `json:"sex"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username"`

	// Usertype corresponds to the JSON schema field "usertype".
	Usertype UserType `json:"usertype"`
}

type UserStakeAdd struct {
	// AmountOfMELD corresponds to the JSON schema field "amountOfMELD".
	AmountOfMELD string `json:"amountOfMELD"`

	// 消息版本号
	Etag int `json:"etag"`

	// StakeLevel corresponds to the JSON schema field "stakeLevel".
	StakeLevel string `json:"stakeLevel"`

	// UserBlockchainAddress corresponds to the JSON schema field
	// "userBlockchainAddress".
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

type UserStakeClaim struct {
	// AmountOfMELD corresponds to the JSON schema field "amountOfMELD".
	AmountOfMELD string `json:"amountOfMELD"`

	// 消息版本号
	Etag int `json:"etag"`

	// StakeLevel corresponds to the JSON schema field "stakeLevel".
	StakeLevel string `json:"stakeLevel"`

	// UserBlockchainAddress corresponds to the JSON schema field
	// "userBlockchainAddress".
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

type UserStakeExpire struct {
	// AmountOfMELD corresponds to the JSON schema field "amountOfMELD".
	AmountOfMELD string `json:"amountOfMELD"`

	// 消息版本号
	Etag int `json:"etag"`

	// StakeLevel corresponds to the JSON schema field "stakeLevel".
	StakeLevel string `json:"stakeLevel"`

	// UserBlockchainAddress corresponds to the JSON schema field
	// "userBlockchainAddress".
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

type UserStakeHarvest struct {
	// 消息版本号
	Etag int `json:"etag"`

	// HarvestAmountOfMELD corresponds to the JSON schema field "harvestAmountOfMELD".
	HarvestAmountOfMELD string `json:"harvestAmountOfMELD"`

	// UserBlockchainAddress corresponds to the JSON schema field
	// "userBlockchainAddress".
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

type UserType string

const UserTypeMANAGER UserType = "MANAGER"
const UserTypeSTUDENT UserType = "STUDENT"
const UserTypeTEACHER UserType = "TEACHER"

type UserType_1 string

const UserType_1_MANAGER UserType_1 = "MANAGER"
const UserType_1_STUDENT UserType_1 = "STUDENT"
const UserType_1_TEACHER UserType_1 = "TEACHER"

type UserUsingNft struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`

	// UsingNfts corresponds to the JSON schema field "usingNfts".
	UsingNfts []UsingNFT `json:"usingNfts"`
}

type UsingNFT struct {
	// 装备位置 对时装和装备有效
	AvatarPos int `json:"avatarPos"`

	// Cid corresponds to the JSON schema field "cid".
	Cid int `json:"cid"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId"`

	// 游戏角色id
	PlayerId string `json:"playerId"`

	// 用户id
	UserId string `json:"userId"`
}

type Web3ServiceAction string

const Web3ServiceActionBatchMintNFTWithItemId Web3ServiceAction = "BatchMintNFTWithItemId"
const Web3ServiceActionBurnNFT Web3ServiceAction = "BurnNFT"
const Web3ServiceActionForgetUserRecipes Web3ServiceAction = "ForgetUserRecipes"
const Web3ServiceActionGetUserNFTsByUserIdAndAddress Web3ServiceAction = "GetUserNFTsByUserIdAndAddress"
const Web3ServiceActionGetUserRecipes Web3ServiceAction = "GetUserRecipes"
const Web3ServiceActionLearnUserRecipes Web3ServiceAction = "LearnUserRecipes"
const Web3ServiceActionMergeByRecipe Web3ServiceAction = "MergeByRecipe"
const Web3ServiceActionMintNFTWithItemId Web3ServiceAction = "MintNFTWithItemId"
const Web3ServiceActionMintNFTWithItemIdAndUserAddress Web3ServiceAction = "MintNFTWithItemIdAndUserAddress"
const Web3ServiceActionMintNFTWithMetadata Web3ServiceAction = "MintNFTWithMetadata"
const Web3ServiceActionUseConsumable Web3ServiceAction = "UseConsumable"
const Web3ServiceActionUseMELD Web3ServiceAction = "UseMELD"

var enumValues_AppId = []interface{}{
	"game-service-main",
	"meland-service",
	"pvp-service",
	"scene-dynamic-service",
	"web3-service",
}
var enumValues_AuthUserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_BatchMintNFTWithItemIdInputQualitysElem = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}
var enumValues_DitaminBurnSource = []interface{}{
	"build3drNFT",
	"buildNFT",
	"buyEnergy",
	"craft",
	"exchange",
}
var enumValues_DitaminBurnSource_1 = []interface{}{
	"build3drNFT",
	"buildNFT",
	"buyEnergy",
	"craft",
	"exchange",
}
var enumValues_DitaminBurnSource_2 = []interface{}{
	"build3drNFT",
	"buildNFT",
	"buyEnergy",
	"craft",
	"exchange",
}
var enumValues_DitaminProduceSource = []interface{}{
	"attackFinlish",
	"deposit",
	"harvest",
}
var enumValues_DitaminProduceSource_1 = []interface{}{
	"attackFinlish",
	"deposit",
	"harvest",
}
var enumValues_GameDataServiceAction = []interface{}{
	"DeductUserExp",
	"GetPlayerInfoByUserId",
	"GetPlayerItemSlots",
	"GetPlayerUsingNftsByUserId",
	"LandUsingSkill",
	"MultiGetPlayerInfoByUserId",
	"MultiGetPlayerUsingNftsByUserId",
	"UpgradePlayerItemSlots",
}
var enumValues_LandServiceAction = []interface{}{
	"Build",
	"Charged",
	"Collection",
	"GetAllBuildData",
	"GetAllLandData",
	"Harvest",
	"MintBattery",
	"Recycling",
}
var enumValues_MelandServiceAction = []interface{}{
	"BurnDitamin",
	"CanBuildNFT",
	"CheckQuestionAnswer",
	"GetInitLandAttributions",
	"GetQuestionResourcesByTypes",
	"GetQuestionsByTypesRandom",
	"GetUserIdByAddress",
	"GetUserNFTs",
	"GetUserTrack",
	"GetUserWeb3Profile",
	"SendMetaTx",
	"SendTx",
}
var enumValues_MintNFTWithItemIdAndUserAddressInputQuality = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}
var enumValues_MintNFTWithItemIdInputQuality = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}
var enumValues_NFTTraitPlaceableLands = []interface{}{
	"Occupied",
	"Ticket",
	"VIP",
}
var enumValues_NFTTraitQuality = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}
var enumValues_NFTTraitRarity = []interface{}{
	"common",
	"epic",
	"mythic",
	"rare",
	"unique",
}
var enumValues_NFTTraitType = []interface{}{
	"Bow",
	"Chest Armor",
	"Consumable",
	"Dagger",
	"Feet Armor",
	"Hands Armor",
	"Head Armor",
	"Legs Armor",
	"Material",
	"MysteryBox",
	"Placeable",
	"Spear",
	"Sword",
	"Wearable",
}
var enumValues_NFTTraitTypes = []interface{}{
	"Attack",
	"Attack Speed",
	"CoreSkillId",
	"Creator",
	"Crit Damage",
	"Crit Points",
	"Defence",
	"Dodge Points",
	"Fertilize",
	"Gender",
	"Get Buff",
	"HP Recovery",
	"Hit Points",
	"Learn Recipe",
	"MaxHP",
	"Move Speed",
	"Occupy Land",
	"Placeable Lands",
	"Quality",
	"Rarity",
	"Requires level",
	"Restore HP",
	"Series",
	"SkillLevel",
	"Sow Seeds",
	"Type",
	"Wearing Position",
}
var enumValues_NFTTraitWearingPosition = []interface{}{
	"Gloves",
	"Head",
	"Lower Body",
	"Shoes",
	"Upper Body",
}
var enumValues_PVPEndType = []interface{}{
	"endTypeTie",
	"endTypeWin",
}
var enumValues_PVPPKSessionStatus = []interface{}{
	"ended",
	"preloading",
	"started",
}
var enumValues_PVPServiceAction = []interface{}{
	"CreatePVPRoom",
	"GetCurrentPkSessionId",
	"GetPlayerPvpProfile",
	"GetPlayerPvpRank",
	"GetPvpHistory",
	"PVPMatchEnter",
	"PVPMatchLeave",
	"PVPRoomPreLeave",
	"PVPRoomReady",
	"PkSessionAgain",
	"PkSessionDoQuestion",
	"PkSessionLoadSuccess",
	"PkSessionUITick",
	"PvpSurrender",
}
var enumValues_PVPSubscriptionEvent = []interface{}{
	"PVPMatchBegin",
}
var enumValues_PVPType = []interface{}{
	"pvpTypeMatch",
	"pvpTypePk",
}
var enumValues_PVPUserType = []interface{}{
	"guest",
	"user",
}
var enumValues_PVPUserType_1 = []interface{}{
	"guest",
	"user",
}
var enumValues_PlayerRebornType = []interface{}{
	"in_place",
	"main_city",
}
var enumValues_PlayerRebornType_1 = []interface{}{
	"in_place",
	"main_city",
}
var enumValues_QuestionType = []interface{}{
	"AdjustClock",
	"BlockCompute",
	"CageShuffle",
	"CardMemory",
	"CuttingArt",
	"HitBrick",
	"MatchingMouse",
	"QuickFlashMemory",
	"ReverseMemory",
	"RotatingSilhouette",
	"SequenceBalloon",
	"SingleChoice",
}
var enumValues_QuestionType_1 = []interface{}{
	"AdjustClock",
	"BlockCompute",
	"CageShuffle",
	"CardMemory",
	"CuttingArt",
	"HitBrick",
	"MatchingMouse",
	"QuickFlashMemory",
	"ReverseMemory",
	"RotatingSilhouette",
	"SequenceBalloon",
	"SingleChoice",
}
var enumValues_SceneDynamicServiceAction = []interface{}{
	"StartServer",
}
var enumValues_Sex = []interface{}{
	"FEMALE",
	"MALE",
}
var enumValues_Sex_1 = []interface{}{
	"FEMALE",
	"MALE",
}
var enumValues_SubscriptionEvent = []interface{}{
	"CloseServer",
	"DitaminBurn",
	"DitaminProduce",
	"FinishQuestion",
	"MELDExchange2Ditamin",
	"MELDFutureExchangeRateChange",
	"MELDFutureMint",
	"MELDFutureRelease",
	"MarketplaceTrade",
	"MultiBuildUpdateEvent",
	"MultiLandDataUpdateEvent",
	"MultiRecyclingEvent",
	"MultiUpdateUserNFT",
	"PlayerDeath",
	"PlayerKilled",
	"PlayerReborn",
	"UnloadEquipment",
	"UpdateUpcomingUses",
	"UpdateUserNFT",
	"UseConsumabled",
	"UseEquipment",
}
var enumValues_UserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_UserType_1 = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_Web3ServiceAction = []interface{}{
	"BatchMintNFTWithItemId",
	"BurnNFT",
	"ForgetUserRecipes",
	"GetUserNFTsByUserIdAndAddress",
	"GetUserRecipes",
	"LearnUserRecipes",
	"MergeByRecipe",
	"MintNFTWithItemId",
	"MintNFTWithItemIdAndUserAddress",
	"MintNFTWithMetadata",
	"UseConsumable",
	"UseMELD",
}
